{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Jaculus - JavaScript runtime for embedded devices","text":"<p>Jaculus allows for running JavaScript code on embedded devices.</p> <p>Currently supports ESP32 and ESP32-S3 SoCs (Github). Core functionality of the device is provided by the Jaculus-dcore library, which can be used to port Jaculus to other platforms.</p> <p>For implementing the runtime environment and communication interface, the Jaculus-machine and Jaculus-link libraries are used, and their documentation can be found on their respective pages.</p>"},{"location":"#guides","title":"Guides","text":"<p>Getting Started Czech tutorials</p> <p>A walkthrough of the setup process and basic usage of Jaculus can be found in the Getting Started guide.</p> <p>We have created a series of Czech tutorials, which guide through basics of JavaScript and Jaculus. These guides were created for the Robotic Camp 2023, where Jaculus was used to teach programming to children.</p>"},{"location":"getting-started/","title":"Getting started","text":""},{"location":"getting-started/#setup","title":"Setup","text":"<p>Make sure, you have Node.js installed. The recommended version is 18.0.0 or newer.</p> <p>Next, install the Jaculus CLI tool:</p> <pre><code>npm install -g jaculus-tools\n</code></pre> <p>Then, you can run the tools using:</p> <pre><code>$ jac\n</code></pre> <p>or</p> <pre><code>$ npx jac\n</code></pre> <p>To connect to the device using serial port, the correct driver must be installed \u2014 most likely CP210x USB to UART Bridge.</p>"},{"location":"getting-started/#installing-jaculus-firmware-to-the-device","title":"Installing Jaculus firmware to the device","text":"<p>First, the Jaculus runtime must be installed on the device.</p> <p>The runtime can be installed using the following command:</p> <pre><code>jac install --package &lt;package.tar.gz&gt; --port &lt;port&gt;\n</code></pre> <p>The command will download the selected package and install it on the device (packages can be found on the downloads page). The package info can be viewed using the <code>--info</code> flag.</p> <p>Verify that the runtime is installed correctly by running:</p> <pre><code>jac version\n</code></pre>"},{"location":"getting-started/#connecting-to-the-device","title":"Connecting to the device","text":"<p>All commands interacting with the device require specifying the device connection using either <code>--port</code> or <code>--socket</code> option.</p> <p>To connect to the device using serial port, use:</p> <pre><code>jac --port &lt;port&gt; &lt;command&gt;\n</code></pre> <p>To connect to the device using TCP socket, use:</p> <pre><code>jac --socket &lt;host&gt;:&lt;port&gt; &lt;command&gt;\n</code></pre> <p>To list available serial ports, use:</p> <pre><code>jac list-ports\n</code></pre> <p>To tunnel serial port over TCP, use:</p> <pre><code>jac serial-socket --port &lt;port&gt; --socket &lt;port&gt;\n</code></pre>"},{"location":"getting-started/#creating-and-running-typescript-programs","title":"Creating and running TypeScript programs","text":"<p>Create a new TypeScript project. A template project for ESP32 with examples is available on GitHub.</p> <p>Compile the project to JavaScript:</p> <pre><code>jac build\n</code></pre> <p>The output will be written to the <code>build</code> directory.</p> <p>Flash the JavaScript program to the device:</p> <pre><code>jac flash\n</code></pre> <p>After flashing, the program will be immediately executed on the device.</p> <p>The entry point of the program is the <code>index.ts</code> file at the root of the project.</p>"},{"location":"getting-started/#creating-and-running-javascript-programs","title":"Creating and running JavaScript programs","text":"<p>Create a directory for your source files.</p> <p>Flash the JavaScript program to the device (<code>&lt;path&gt;</code> should point to the source directory):</p> <pre><code>jac flash --from &lt;path&gt;\n</code></pre> <p>After flashing, the program will be immediately executed on the device.</p> <p>The entry point of the program is the <code>index.js</code> file in the source directory.</p>"},{"location":"getting-started/#controlling-the-device-and-monitoring-its-output","title":"Controlling the device and monitoring its output","text":"<p>To control the device, use the following commands:</p> <pre><code>jac start\njac stop\njac status\njac monitor\n</code></pre>"},{"location":"getting-started/#updating-the-firmware","title":"Updating the firmware","text":"<p>To update the firmware, just install the new runtime package using the <code>install</code> command.</p> <p>Note that this will erase all data stored on the device. It may be also necessary to update the type definitions for the runtime. They can be found in the example project on GitHub.</p>"},{"location":"troubleshooting/","title":"Troubleshooting","text":"<p>Some problems that may occur when using Jaculus and how to fix them.</p>"},{"location":"troubleshooting/#command-stuck-on-connected-and-not-doing-anything","title":"Command stuck on \"Connected\" and not doing anything","text":"<p>This means that the device does not respond to the communication. This can be caused by several things:</p> <ul> <li>The firmware is halted or otherwise not responding</li> <li>The device is stuck in a boot loop</li> <li>The device is not a Jaculus device</li> <li>Jaculus-tools version is incompatible with the device firmware</li> </ul> <p>To fix this, try the following:</p> <ul> <li>Check that you are connecting to the correct port</li> <li>Reset the device by pressing the reset button</li> <li>Unplug and replug the device</li> <li>Flash the Jaculus firmware again (Getting started)</li> <li>Update Jaculus-tools and device firmware to the latest version</li> </ul>"},{"location":"troubleshooting/#command-flash-stuck-on-one-file","title":"Command \"flash\" stuck on one file","text":"<p>This can be caused by several things:</p> <ul> <li>The device crashed while uploading the file</li> <li>The filesystem on the device is corrupted</li> </ul> <p>To fix this, try the following:</p> <ul> <li>Reset the device by pressing the reset button</li> <li>Unplug and replug the device</li> <li>Flash the Jaculus firmware again (Getting started)</li> </ul>"},{"location":"doxygen/annotated/","title":"Class List","text":"<p>Here are the classes, structs, unions and interfaces with brief descriptions:</p> <ul> <li>namespace jac <ul> <li>class Controller </li> <li>class Device </li> <li>class KeyValueFeature </li> <li>class KeyValueNamespace </li> <li>struct KeyValueNamespaceProtoBuilder </li> <li>class LinkReadable </li> <li>class LinkWritable </li> <li>struct Logger </li> <li>class MachineCtrl </li> <li>namespace ProtoBuilder </li> <li>class Sha1Hasher </li> <li>class Timeout </li> <li>class TimeoutLock </li> <li>class Uploader </li> </ul> </li> <li>struct MachineIO </li> <li>struct mbedtls_sha1_context The SHA-1 context structure. </li> </ul>"},{"location":"doxygen/files/","title":"File List","text":"<p>Here is a list of all files with brief descriptions:</p> <ul> <li>dir src <ul> <li>dir jac <ul> <li>dir device <ul> <li>file controller.cpp </li> <li>file controller.h </li> <li>file device.h </li> <li>file keyvalue.h </li> <li>file logger.cpp </li> <li>file logger.h </li> <li>dir util <ul> <li>file lock.h </li> <li>file machineCtrl.h </li> <li>file sha1.h This file contains SHA-1 definitions and functions. </li> <li>file timeout.h </li> </ul> </li> <li>file uploader.cpp </li> <li>file uploader.h </li> </ul> </li> <li>dir features <ul> <li>file keyvalueFeature.h </li> <li>dir util <ul> <li>file linkIo.h </li> </ul> </li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"doxygen/namespacejac/","title":"Namespace jac","text":"<p>Namespace List &gt; jac</p>"},{"location":"doxygen/namespacejac/#namespaces","title":"Namespaces","text":"Type Name namespace ProtoBuilder"},{"location":"doxygen/namespacejac/#classes","title":"Classes","text":"Type Name class Controller class Device &lt;class Machine&gt; class KeyValueFeature &lt;class Next&gt; class KeyValueNamespace struct KeyValueNamespaceProtoBuilder class LinkReadable &lt;class Machine&gt; class LinkWritable struct Logger class MachineCtrl class Sha1Hasher class Timeout class TimeoutLock class Uploader"},{"location":"doxygen/namespacejac/#public-types","title":"Public Types","text":"Type Name typedef std::function&lt; std::unique_ptr&lt; KeyValueNamespace &gt;(const std::string &amp;)&gt; KeyValueOpener"},{"location":"doxygen/namespacejac/#public-static-functions","title":"Public Static Functions","text":"Type Name bool deleteDir (std::filesystem::path &amp; path, bool onlyContents)  std::optional&lt; std::filesystem::path &gt; getAbsolute (std::string filename, std::filesystem::path &amp; rootDir)  std::optional&lt; std::pair&lt; std::vector&lt; std::string &gt;, size_t &gt; &gt; listDir (std::filesystem::path &amp; path)"},{"location":"doxygen/namespacejac/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxygen/namespacejac/#typedef-keyvalueopener","title":"typedef KeyValueOpener","text":"<pre><code>using jac::KeyValueOpener = typedef std::function&lt;std::unique_ptr&lt;KeyValueNamespace&gt;(const std::string&amp;)&gt;;\n</code></pre>"},{"location":"doxygen/namespacejac/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/namespacejac/#function-deletedir","title":"function deleteDir","text":"<pre><code>static bool jac::deleteDir (\n    std::filesystem::path &amp; path,\n    bool onlyContents\n) \n</code></pre>"},{"location":"doxygen/namespacejac/#function-getabsolute","title":"function getAbsolute","text":"<pre><code>static std::optional&lt; std::filesystem::path &gt; jac::getAbsolute (\n    std::string filename,\n    std::filesystem::path &amp; rootDir\n) \n</code></pre>"},{"location":"doxygen/namespacejac/#function-listdir","title":"function listDir","text":"<pre><code>static std::optional&lt; std::pair&lt; std::vector&lt; std::string &gt;, size_t &gt; &gt; jac::listDir (\n    std::filesystem::path &amp; path\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/device/controller.cpp</code></p>"},{"location":"doxygen/classjac_1_1Controller/","title":"Class jac::Controller","text":"<p>ClassList &gt; jac &gt; Controller</p>"},{"location":"doxygen/classjac_1_1Controller/#public-functions","title":"Public Functions","text":"Type Name Controller (std::unique_ptr&lt; InputPacketCommunicator &gt; input, std::unique_ptr&lt; OutputPacketCommunicator &gt; output, TimeoutLock &amp; lock, MachineCtrl &amp; machineCtrl, std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp; versionInfo)  void start ()  ~Controller ()"},{"location":"doxygen/classjac_1_1Controller/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1Controller/#function-controller","title":"function Controller","text":"<pre><code>inline jac::Controller::Controller (\n    std::unique_ptr&lt; InputPacketCommunicator &gt; input,\n    std::unique_ptr&lt; OutputPacketCommunicator &gt; output,\n    TimeoutLock &amp; lock,\n    MachineCtrl &amp; machineCtrl,\n    std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; &amp; versionInfo\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1Controller/#function-start","title":"function start","text":"<pre><code>inline void jac::Controller::start () \n</code></pre>"},{"location":"doxygen/classjac_1_1Controller/#function-controller_1","title":"function ~Controller","text":"<pre><code>inline jac::Controller::~Controller () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/device/controller.h</code></p>"},{"location":"doxygen/classjac_1_1Device/","title":"Class jac::Device","text":"<p>template &lt;class Machine&gt;</p> <p>ClassList &gt; jac &gt; Device</p> <p>Inherits the following classes: jac::MachineCtrl</p>"},{"location":"doxygen/classjac_1_1Device/#public-functions","title":"Public Functions","text":"Type Name Device (std::filesystem::path rootDir, std::function&lt; std::string()&gt; getMemoryStats, std::function&lt; std::string()&gt; getStorageStats, std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; versionInfo, std::function&lt; void(std::filesystem::path)&gt; formatFS, std::unordered_map&lt; std::string, std::span&lt; const uint8_t &gt; &gt; resources, KeyValueOpener openKeyValueNamespace)  Device (const Device &amp;) = delete Device (Device &amp;&amp;) = delete virtual void emitKeyValueModified (const std::string &amp; nsname, const std::string &amp; key) override const KeyValueOpener &amp; getKeyValueOpener () const virtual std::tuple&lt; bool, int, std::string &gt; getMachineStatus () override TimeoutLock &amp; lock ()  MachineIO &amp; machineIO ()  void onConfigureMachine (std::function&lt; void(Machine &amp;)&gt; f)  void onKeyValueModified (std::function&lt; void(const std::string &amp;, const std::string &amp;)&gt; f)  virtual std::unique_ptr&lt; KeyValueNamespace &gt; openKeyValue (const std::string &amp; nsname) override const Device &amp; operator= (const Device &amp;) = delete Device &amp; operator= (Device &amp;&amp;) = delete Router &amp; router ()  void start ()  virtual bool startMachine (std::string path) override virtual bool stopMachine () override ~Device ()"},{"location":"doxygen/classjac_1_1Device/#public-functions-inherited-from-jacmachinectrl","title":"Public Functions inherited from jac::MachineCtrl","text":"<p>See jac::MachineCtrl</p> Type Name virtual void emitKeyValueModified (const std::string &amp; nsname, const std::string &amp; key) = 0 virtual std::tuple&lt; bool, int, std::string &gt; getMachineStatus () = 0 virtual std::unique_ptr&lt; KeyValueNamespace &gt; openKeyValue (const std::string &amp; nsname) const = 0 virtual bool startMachine (std::string path) = 0 virtual bool stopMachine () = 0"},{"location":"doxygen/classjac_1_1Device/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1Device/#function-device-13","title":"function Device [1/3]","text":"<pre><code>inline jac::Device::Device (\n    std::filesystem::path rootDir,\n    std::function&lt; std::string()&gt; getMemoryStats,\n    std::function&lt; std::string()&gt; getStorageStats,\n    std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; versionInfo,\n    std::function&lt; void (std::filesystem::path)&gt; formatFS,\n    std::unordered_map&lt; std::string, std::span&lt; const  uint8_t &gt; &gt; resources,\n    KeyValueOpener openKeyValueNamespace\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1Device/#function-device-23","title":"function Device [2/3]","text":"<pre><code>jac::Device::Device (\n    const  Device &amp;\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1Device/#function-device-33","title":"function Device [3/3]","text":"<pre><code>jac::Device::Device (\n    Device &amp;&amp;\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1Device/#function-emitkeyvaluemodified","title":"function emitKeyValueModified","text":"<pre><code>inline virtual void jac::Device::emitKeyValueModified (\n    const std::string &amp; nsname,\n    const std::string &amp; key\n) override\n</code></pre> <p>Implements jac::MachineCtrl::emitKeyValueModified</p>"},{"location":"doxygen/classjac_1_1Device/#function-getkeyvalueopener","title":"function getKeyValueOpener","text":"<pre><code>inline const KeyValueOpener &amp; jac::Device::getKeyValueOpener () const\n</code></pre>"},{"location":"doxygen/classjac_1_1Device/#function-getmachinestatus","title":"function getMachineStatus","text":"<pre><code>virtual std::tuple&lt; bool , int , std::string &gt; jac::Device::getMachineStatus () override\n</code></pre> <p>Implements jac::MachineCtrl::getMachineStatus</p>"},{"location":"doxygen/classjac_1_1Device/#function-lock","title":"function lock","text":"<pre><code>inline TimeoutLock &amp; jac::Device::lock () \n</code></pre>"},{"location":"doxygen/classjac_1_1Device/#function-machineio","title":"function machineIO","text":"<pre><code>inline MachineIO &amp; jac::Device::machineIO () \n</code></pre>"},{"location":"doxygen/classjac_1_1Device/#function-onconfiguremachine","title":"function onConfigureMachine","text":"<pre><code>inline void jac::Device::onConfigureMachine (\n    std::function&lt; void ( Machine &amp;)&gt; f\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1Device/#function-onkeyvaluemodified","title":"function onKeyValueModified","text":"<pre><code>inline void jac::Device::onKeyValueModified (\n    std::function&lt; void ( const std::string &amp;, const std::string &amp;)&gt; f\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1Device/#function-openkeyvalue","title":"function openKeyValue","text":"<pre><code>inline virtual std::unique_ptr&lt; KeyValueNamespace &gt; jac::Device::openKeyValue (\n    const std::string &amp; nsname\n) override const\n</code></pre> <p>Implements jac::MachineCtrl::openKeyValue</p>"},{"location":"doxygen/classjac_1_1Device/#function-operator","title":"function operator=","text":"<pre><code>Device &amp; jac::Device::operator= (\n    const  Device &amp;\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1Device/#function-operator_1","title":"function operator=","text":"<pre><code>Device &amp; jac::Device::operator= (\n    Device &amp;&amp;\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1Device/#function-router","title":"function router","text":"<pre><code>inline Router &amp; jac::Device::router () \n</code></pre>"},{"location":"doxygen/classjac_1_1Device/#function-start","title":"function start","text":"<pre><code>inline void jac::Device::start () \n</code></pre>"},{"location":"doxygen/classjac_1_1Device/#function-startmachine","title":"function startMachine","text":"<pre><code>virtual bool jac::Device::startMachine (\n    std::string path\n) override\n</code></pre> <p>Implements jac::MachineCtrl::startMachine</p>"},{"location":"doxygen/classjac_1_1Device/#function-stopmachine","title":"function stopMachine","text":"<pre><code>virtual bool jac::Device::stopMachine () override\n</code></pre> <p>Implements jac::MachineCtrl::stopMachine</p>"},{"location":"doxygen/classjac_1_1Device/#function-device","title":"function ~Device","text":"<pre><code>inline jac::Device::~Device () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/device/device.h</code></p>"},{"location":"doxygen/classjac_1_1KeyValueFeature/","title":"Class jac::KeyValueFeature","text":"<p>template &lt;class Next&gt;</p> <p>ClassList &gt; jac &gt; KeyValueFeature</p> <p>Inherits the following classes: Next</p>"},{"location":"doxygen/classjac_1_1KeyValueFeature/#public-types","title":"Public Types","text":"Type Name typedef jac::Class&lt; KeyValueNamespaceProtoBuilder &gt; KvClass"},{"location":"doxygen/classjac_1_1KeyValueFeature/#public-attributes","title":"Public Attributes","text":"Type Name jac::KeyValueOpener kvOpener"},{"location":"doxygen/classjac_1_1KeyValueFeature/#public-functions","title":"Public Functions","text":"Type Name KeyValueFeature ()  void initialize ()"},{"location":"doxygen/classjac_1_1KeyValueFeature/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxygen/classjac_1_1KeyValueFeature/#typedef-kvclass","title":"typedef KvClass","text":"<pre><code>using jac::KeyValueFeature&lt; Next &gt;::KvClass =  jac::Class&lt;KeyValueNamespaceProtoBuilder&gt;;\n</code></pre>"},{"location":"doxygen/classjac_1_1KeyValueFeature/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxygen/classjac_1_1KeyValueFeature/#variable-kvopener","title":"variable kvOpener","text":"<pre><code>jac::KeyValueOpener jac::KeyValueFeature&lt; Next &gt;::kvOpener;\n</code></pre>"},{"location":"doxygen/classjac_1_1KeyValueFeature/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1KeyValueFeature/#function-keyvaluefeature","title":"function KeyValueFeature","text":"<pre><code>inline jac::KeyValueFeature::KeyValueFeature () \n</code></pre>"},{"location":"doxygen/classjac_1_1KeyValueFeature/#function-initialize","title":"function initialize","text":"<pre><code>inline void jac::KeyValueFeature::initialize () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/features/keyvalueFeature.h</code></p>"},{"location":"doxygen/classjac_1_1KeyValueNamespace/","title":"Class jac::KeyValueNamespace","text":"<p>ClassList &gt; jac &gt; KeyValueNamespace</p>"},{"location":"doxygen/classjac_1_1KeyValueNamespace/#public-types","title":"Public Types","text":"Type Name enum uint8_t DataType"},{"location":"doxygen/classjac_1_1KeyValueNamespace/#public-functions","title":"Public Functions","text":"Type Name KeyValueNamespace ()  virtual bool commit () = 0 virtual bool erase (const std::string &amp; name) = 0 bool exists (const std::string &amp; name)  virtual float getFloat (const std::string &amp; name, float def_value=0.f) = 0 virtual int64_t getInt (const std::string &amp; name, int64_t def_value=0) = 0 virtual std::string getString (const std::string &amp; name, std::string def_value=\"\") = 0 virtual DataType getType (const std::string &amp; name) = 0 virtual std::vector&lt; std::string &gt; keys () = 0 virtual void setFloat (const std::string &amp; name, float value) = 0 virtual void setInt (const std::string &amp; name, int64_t value) = 0 virtual void setString (const std::string &amp; name, const std::string &amp; value) = 0 virtual ~KeyValueNamespace ()"},{"location":"doxygen/classjac_1_1KeyValueNamespace/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxygen/classjac_1_1KeyValueNamespace/#enum-datatype","title":"enum DataType","text":"<pre><code>enum jac::KeyValueNamespace::DataType {\n    INT64 = 0,\n    FLOAT32 = 1,\n    STRING = 2,\n    NOT_FOUND = 0xFF\n};\n</code></pre>"},{"location":"doxygen/classjac_1_1KeyValueNamespace/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1KeyValueNamespace/#function-keyvaluenamespace-22","title":"function KeyValueNamespace [2/2]","text":"<pre><code>inline jac::KeyValueNamespace::KeyValueNamespace () \n</code></pre>"},{"location":"doxygen/classjac_1_1KeyValueNamespace/#function-commit","title":"function commit","text":"<pre><code>virtual bool jac::KeyValueNamespace::commit () = 0\n</code></pre>"},{"location":"doxygen/classjac_1_1KeyValueNamespace/#function-erase","title":"function erase","text":"<pre><code>virtual bool jac::KeyValueNamespace::erase (\n    const std::string &amp; name\n) = 0\n</code></pre>"},{"location":"doxygen/classjac_1_1KeyValueNamespace/#function-exists","title":"function exists","text":"<pre><code>inline bool jac::KeyValueNamespace::exists (\n    const std::string &amp; name\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1KeyValueNamespace/#function-getfloat","title":"function getFloat","text":"<pre><code>virtual float jac::KeyValueNamespace::getFloat (\n    const std::string &amp; name,\n    float def_value=0. f\n) = 0\n</code></pre>"},{"location":"doxygen/classjac_1_1KeyValueNamespace/#function-getint","title":"function getInt","text":"<pre><code>virtual int64_t jac::KeyValueNamespace::getInt (\n    const std::string &amp; name,\n    int64_t def_value=0\n) = 0\n</code></pre>"},{"location":"doxygen/classjac_1_1KeyValueNamespace/#function-getstring","title":"function getString","text":"<pre><code>virtual std::string jac::KeyValueNamespace::getString (\n    const std::string &amp; name,\n    std::string def_value=\"\"\n) = 0\n</code></pre>"},{"location":"doxygen/classjac_1_1KeyValueNamespace/#function-gettype","title":"function getType","text":"<pre><code>virtual DataType jac::KeyValueNamespace::getType (\n    const std::string &amp; name\n) = 0\n</code></pre>"},{"location":"doxygen/classjac_1_1KeyValueNamespace/#function-keys","title":"function keys","text":"<pre><code>virtual std::vector&lt; std::string &gt; jac::KeyValueNamespace::keys () = 0\n</code></pre>"},{"location":"doxygen/classjac_1_1KeyValueNamespace/#function-setfloat","title":"function setFloat","text":"<pre><code>virtual void jac::KeyValueNamespace::setFloat (\n    const std::string &amp; name,\n    float value\n) = 0\n</code></pre>"},{"location":"doxygen/classjac_1_1KeyValueNamespace/#function-setint","title":"function setInt","text":"<pre><code>virtual void jac::KeyValueNamespace::setInt (\n    const std::string &amp; name,\n    int64_t value\n) = 0\n</code></pre>"},{"location":"doxygen/classjac_1_1KeyValueNamespace/#function-setstring","title":"function setString","text":"<pre><code>virtual void jac::KeyValueNamespace::setString (\n    const std::string &amp; name,\n    const std::string &amp; value\n) = 0\n</code></pre>"},{"location":"doxygen/classjac_1_1KeyValueNamespace/#function-keyvaluenamespace","title":"function ~KeyValueNamespace","text":"<pre><code>inline virtual jac::KeyValueNamespace::~KeyValueNamespace () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/device/keyvalue.h</code></p>"},{"location":"doxygen/structjac_1_1KeyValueNamespaceProtoBuilder/","title":"Struct jac::KeyValueNamespaceProtoBuilder","text":"<p>ClassList &gt; jac &gt; KeyValueNamespaceProtoBuilder</p> <p>Inherits the following classes: jac::ProtoBuilder::Opaque&lt; jac::KeyValueNamespace &gt;,  jac::ProtoBuilder::Properties</p>"},{"location":"doxygen/structjac_1_1KeyValueNamespaceProtoBuilder/#public-static-functions","title":"Public Static Functions","text":"Type Name void addProperties (JSContext * ctx, jac::Object proto)  jac::Value get (jac::ContextRef ctx, jac::ValueWeak thisVal, std::string key)"},{"location":"doxygen/structjac_1_1KeyValueNamespaceProtoBuilder/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/structjac_1_1KeyValueNamespaceProtoBuilder/#function-addproperties","title":"function addProperties","text":"<pre><code>static inline void jac::KeyValueNamespaceProtoBuilder::addProperties (\n    JSContext * ctx,\n    jac::Object proto\n) \n</code></pre>"},{"location":"doxygen/structjac_1_1KeyValueNamespaceProtoBuilder/#function-get","title":"function get","text":"<pre><code>static inline jac::Value jac::KeyValueNamespaceProtoBuilder::get (\n    jac::ContextRef ctx,\n    jac::ValueWeak thisVal,\n    std::string key\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/features/keyvalueFeature.h</code></p>"},{"location":"doxygen/classjac_1_1LinkReadable/","title":"Class jac::LinkReadable","text":"<p>template &lt;class Machine&gt;</p> <p>ClassList &gt; jac &gt; LinkReadable</p> <p>Inherits the following classes: Readable</p>"},{"location":"doxygen/classjac_1_1LinkReadable/#public-functions","title":"Public Functions","text":"Type Name LinkReadable (Machine * machine, jac::InputStreamCommunicator * comm)  LinkReadable (LinkReadable &amp;) = delete LinkReadable (LinkReadable &amp;&amp;) = delete bool get (std::function&lt; void(char)&gt; callback) override bool read (std::function&lt; void(std::string)&gt; callback) override ~LinkReadable () override"},{"location":"doxygen/classjac_1_1LinkReadable/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1LinkReadable/#function-linkreadable-13","title":"function LinkReadable [1/3]","text":"<pre><code>inline jac::LinkReadable::LinkReadable (\n    Machine * machine,\n    jac::InputStreamCommunicator * comm\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1LinkReadable/#function-linkreadable-23","title":"function LinkReadable [2/3]","text":"<pre><code>jac::LinkReadable::LinkReadable (\n    LinkReadable &amp;\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1LinkReadable/#function-linkreadable-33","title":"function LinkReadable [3/3]","text":"<pre><code>jac::LinkReadable::LinkReadable (\n    LinkReadable &amp;&amp;\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1LinkReadable/#function-get","title":"function get","text":"<pre><code>inline bool jac::LinkReadable::get (\n    std::function&lt; void ( char )&gt; callback\n) override\n</code></pre>"},{"location":"doxygen/classjac_1_1LinkReadable/#function-read","title":"function read","text":"<pre><code>inline bool jac::LinkReadable::read (\n    std::function&lt; void (std::string)&gt; callback\n) override\n</code></pre>"},{"location":"doxygen/classjac_1_1LinkReadable/#function-linkreadable","title":"function ~LinkReadable","text":"<pre><code>inline jac::LinkReadable::~LinkReadable () override\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/features/util/linkIo.h</code></p>"},{"location":"doxygen/classjac_1_1LinkWritable/","title":"Class jac::LinkWritable","text":"<p>ClassList &gt; jac &gt; LinkWritable</p> <p>Inherits the following classes: Writable</p>"},{"location":"doxygen/classjac_1_1LinkWritable/#public-functions","title":"Public Functions","text":"Type Name LinkWritable (jac::OutputStreamCommunicator * comm)  void write (std::string data) override"},{"location":"doxygen/classjac_1_1LinkWritable/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1LinkWritable/#function-linkwritable","title":"function LinkWritable","text":"<pre><code>inline jac::LinkWritable::LinkWritable (\n    jac::OutputStreamCommunicator * comm\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1LinkWritable/#function-write","title":"function write","text":"<pre><code>inline void jac::LinkWritable::write (\n    std::string data\n) override\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/features/util/linkIo.h</code></p>"},{"location":"doxygen/structjac_1_1Logger/","title":"Struct jac::Logger","text":"<p>ClassList &gt; jac &gt; Logger</p>"},{"location":"doxygen/structjac_1_1Logger/#public-static-attributes","title":"Public Static Attributes","text":"Type Name std::unique_ptr&lt; OutputStreamCommunicator &gt; _debugStream std::unique_ptr&lt; OutputStreamCommunicator &gt; _errorStream std::unique_ptr&lt; OutputStreamCommunicator &gt; _logStream"},{"location":"doxygen/structjac_1_1Logger/#public-static-functions","title":"Public Static Functions","text":"Type Name void debug (std::string message)  void error (std::string message)  void log (std::string message)"},{"location":"doxygen/structjac_1_1Logger/#public-static-attributes-documentation","title":"Public Static Attributes Documentation","text":""},{"location":"doxygen/structjac_1_1Logger/#variable-_debugstream","title":"variable _debugStream","text":"<pre><code>std::unique_ptr&lt; OutputStreamCommunicator &gt; jac::Logger::_debugStream;\n</code></pre>"},{"location":"doxygen/structjac_1_1Logger/#variable-_errorstream","title":"variable _errorStream","text":"<pre><code>std::unique_ptr&lt; OutputStreamCommunicator &gt; jac::Logger::_errorStream;\n</code></pre>"},{"location":"doxygen/structjac_1_1Logger/#variable-_logstream","title":"variable _logStream","text":"<pre><code>std::unique_ptr&lt; OutputStreamCommunicator &gt; jac::Logger::_logStream;\n</code></pre>"},{"location":"doxygen/structjac_1_1Logger/#public-static-functions-documentation","title":"Public Static Functions Documentation","text":""},{"location":"doxygen/structjac_1_1Logger/#function-debug","title":"function debug","text":"<pre><code>static inline void jac::Logger::debug (\n    std::string message\n) \n</code></pre>"},{"location":"doxygen/structjac_1_1Logger/#function-error","title":"function error","text":"<pre><code>static inline void jac::Logger::error (\n    std::string message\n) \n</code></pre>"},{"location":"doxygen/structjac_1_1Logger/#function-log","title":"function log","text":"<pre><code>static inline void jac::Logger::log (\n    std::string message\n) \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/device/logger.h</code></p>"},{"location":"doxygen/classjac_1_1MachineCtrl/","title":"Class jac::MachineCtrl","text":"<p>ClassList &gt; jac &gt; MachineCtrl</p> <p>Inherited by the following classes: jac::Device</p>"},{"location":"doxygen/classjac_1_1MachineCtrl/#public-functions","title":"Public Functions","text":"Type Name virtual void emitKeyValueModified (const std::string &amp; nsname, const std::string &amp; key) = 0 virtual std::tuple&lt; bool, int, std::string &gt; getMachineStatus () = 0 virtual std::unique_ptr&lt; KeyValueNamespace &gt; openKeyValue (const std::string &amp; nsname) const = 0 virtual bool startMachine (std::string path) = 0 virtual bool stopMachine () = 0"},{"location":"doxygen/classjac_1_1MachineCtrl/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1MachineCtrl/#function-emitkeyvaluemodified","title":"function emitKeyValueModified","text":"<pre><code>virtual void jac::MachineCtrl::emitKeyValueModified (\n    const std::string &amp; nsname,\n    const std::string &amp; key\n) = 0\n</code></pre>"},{"location":"doxygen/classjac_1_1MachineCtrl/#function-getmachinestatus","title":"function getMachineStatus","text":"<pre><code>virtual std::tuple&lt; bool , int , std::string &gt; jac::MachineCtrl::getMachineStatus () = 0\n</code></pre>"},{"location":"doxygen/classjac_1_1MachineCtrl/#function-openkeyvalue","title":"function openKeyValue","text":"<pre><code>virtual std::unique_ptr&lt; KeyValueNamespace &gt; jac::MachineCtrl::openKeyValue (\n    const std::string &amp; nsname\n) const = 0\n</code></pre>"},{"location":"doxygen/classjac_1_1MachineCtrl/#function-startmachine","title":"function startMachine","text":"<pre><code>virtual bool jac::MachineCtrl::startMachine (\n    std::string path\n) = 0\n</code></pre>"},{"location":"doxygen/classjac_1_1MachineCtrl/#function-stopmachine","title":"function stopMachine","text":"<pre><code>virtual bool jac::MachineCtrl::stopMachine () = 0\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/device/util/machineCtrl.h</code></p>"},{"location":"doxygen/namespacejac_1_1ProtoBuilder/","title":"Namespace jac::ProtoBuilder","text":"<p>Namespace List &gt; jac &gt; ProtoBuilder</p> <p>The documentation for this class was generated from the following file <code>[generated]</code></p>"},{"location":"doxygen/classjac_1_1Sha1Hasher/","title":"Class jac::Sha1Hasher","text":"<p>ClassList &gt; jac &gt; Sha1Hasher</p>"},{"location":"doxygen/classjac_1_1Sha1Hasher/#public-functions","title":"Public Functions","text":"Type Name Sha1Hasher ()  Sha1Hasher (const Sha1Hasher &amp;) = delete std::span&lt; const uint8_t, 20 &gt; processFile (const std::filesystem::path &amp; path)  ~Sha1Hasher ()"},{"location":"doxygen/classjac_1_1Sha1Hasher/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1Sha1Hasher/#function-sha1hasher-12","title":"function Sha1Hasher [1/2]","text":"<pre><code>inline jac::Sha1Hasher::Sha1Hasher () \n</code></pre>"},{"location":"doxygen/classjac_1_1Sha1Hasher/#function-sha1hasher-22","title":"function Sha1Hasher [2/2]","text":"<pre><code>jac::Sha1Hasher::Sha1Hasher (\n    const  Sha1Hasher &amp;\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1Sha1Hasher/#function-processfile","title":"function processFile","text":"<pre><code>inline std::span&lt; const  uint8_t , 20 &gt; jac::Sha1Hasher::processFile (\n    const std::filesystem::path &amp; path\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1Sha1Hasher/#function-sha1hasher","title":"function ~Sha1Hasher","text":"<pre><code>inline jac::Sha1Hasher::~Sha1Hasher () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/device/uploader.cpp</code></p>"},{"location":"doxygen/classjac_1_1Timeout/","title":"Class jac::Timeout","text":"<p>ClassList &gt; jac &gt; Timeout</p>"},{"location":"doxygen/classjac_1_1Timeout/#public-functions","title":"Public Functions","text":"Type Name Timeout (std::chrono::milliseconds duration)  Timeout (const Timeout &amp;) = delete Timeout (Timeout &amp;&amp;) = delete void init ()  Timeout &amp; operator= (const Timeout &amp;) = delete Timeout &amp; operator= (Timeout &amp;&amp;) = delete void reset ()  void start (std::function&lt; void()&gt; callback)  void stop ()  ~Timeout ()"},{"location":"doxygen/classjac_1_1Timeout/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1Timeout/#function-timeout-13","title":"function Timeout [1/3]","text":"<pre><code>inline jac::Timeout::Timeout (\n    std::chrono::milliseconds duration\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1Timeout/#function-timeout-23","title":"function Timeout [2/3]","text":"<pre><code>jac::Timeout::Timeout (\n    const  Timeout &amp;\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1Timeout/#function-timeout-33","title":"function Timeout [3/3]","text":"<pre><code>jac::Timeout::Timeout (\n    Timeout &amp;&amp;\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1Timeout/#function-init","title":"function init","text":"<pre><code>inline void jac::Timeout::init () \n</code></pre>"},{"location":"doxygen/classjac_1_1Timeout/#function-operator","title":"function operator=","text":"<pre><code>Timeout &amp; jac::Timeout::operator= (\n    const  Timeout &amp;\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1Timeout/#function-operator_1","title":"function operator=","text":"<pre><code>Timeout &amp; jac::Timeout::operator= (\n    Timeout &amp;&amp;\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1Timeout/#function-reset","title":"function reset","text":"<pre><code>inline void jac::Timeout::reset () \n</code></pre>"},{"location":"doxygen/classjac_1_1Timeout/#function-start","title":"function start","text":"<pre><code>inline void jac::Timeout::start (\n    std::function&lt; void ()&gt; callback\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1Timeout/#function-stop","title":"function stop","text":"<pre><code>inline void jac::Timeout::stop () \n</code></pre>"},{"location":"doxygen/classjac_1_1Timeout/#function-timeout","title":"function ~Timeout","text":"<pre><code>inline jac::Timeout::~Timeout () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/device/util/timeout.h</code></p>"},{"location":"doxygen/classjac_1_1TimeoutLock/","title":"Class jac::TimeoutLock","text":"<p>ClassList &gt; jac &gt; TimeoutLock</p>"},{"location":"doxygen/classjac_1_1TimeoutLock/#public-functions","title":"Public Functions","text":"Type Name TimeoutLock (std::chrono::milliseconds duration, std::function&lt; void()&gt; callback)  TimeoutLock (const TimeoutLock &amp;) = delete TimeoutLock (TimeoutLock &amp;&amp;) = delete void forceUnlock ()  void init ()  bool lock (int who)  TimeoutLock &amp; operator= (const TimeoutLock &amp;) = delete TimeoutLock &amp; operator= (TimeoutLock &amp;&amp;) = delete bool ownedBy (int who)  void resetTimeout (int who)  void stopTimeout (int who)  bool unlock (int who)  ~TimeoutLock ()"},{"location":"doxygen/classjac_1_1TimeoutLock/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1TimeoutLock/#function-timeoutlock-13","title":"function TimeoutLock [1/3]","text":"<pre><code>inline jac::TimeoutLock::TimeoutLock (\n    std::chrono::milliseconds duration,\n    std::function&lt; void ()&gt; callback\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1TimeoutLock/#function-timeoutlock-23","title":"function TimeoutLock [2/3]","text":"<pre><code>jac::TimeoutLock::TimeoutLock (\n    const  TimeoutLock &amp;\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1TimeoutLock/#function-timeoutlock-33","title":"function TimeoutLock [3/3]","text":"<pre><code>jac::TimeoutLock::TimeoutLock (\n    TimeoutLock &amp;&amp;\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1TimeoutLock/#function-forceunlock","title":"function forceUnlock","text":"<pre><code>inline void jac::TimeoutLock::forceUnlock () \n</code></pre>"},{"location":"doxygen/classjac_1_1TimeoutLock/#function-init","title":"function init","text":"<pre><code>inline void jac::TimeoutLock::init () \n</code></pre>"},{"location":"doxygen/classjac_1_1TimeoutLock/#function-lock","title":"function lock","text":"<pre><code>inline bool jac::TimeoutLock::lock (\n    int who\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1TimeoutLock/#function-operator","title":"function operator=","text":"<pre><code>TimeoutLock &amp; jac::TimeoutLock::operator= (\n    const  TimeoutLock &amp;\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1TimeoutLock/#function-operator_1","title":"function operator=","text":"<pre><code>TimeoutLock &amp; jac::TimeoutLock::operator= (\n    TimeoutLock &amp;&amp;\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1TimeoutLock/#function-ownedby","title":"function ownedBy","text":"<pre><code>inline bool jac::TimeoutLock::ownedBy (\n    int who\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1TimeoutLock/#function-resettimeout","title":"function resetTimeout","text":"<pre><code>inline void jac::TimeoutLock::resetTimeout (\n    int who\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1TimeoutLock/#function-stoptimeout","title":"function stopTimeout","text":"<pre><code>inline void jac::TimeoutLock::stopTimeout (\n    int who\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1TimeoutLock/#function-unlock","title":"function unlock","text":"<pre><code>inline bool jac::TimeoutLock::unlock (\n    int who\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1TimeoutLock/#function-timeoutlock","title":"function ~TimeoutLock","text":"<pre><code>inline jac::TimeoutLock::~TimeoutLock () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/device/util/lock.h</code></p>"},{"location":"doxygen/classjac_1_1Uploader/","title":"Class jac::Uploader","text":"<p>ClassList &gt; jac &gt; Uploader</p>"},{"location":"doxygen/classjac_1_1Uploader/#public-types","title":"Public Types","text":"Type Name enum uint8_t Command enum uint8_t Error"},{"location":"doxygen/classjac_1_1Uploader/#public-functions","title":"Public Functions","text":"Type Name Uploader (std::unique_ptr&lt; InputPacketCommunicator &gt; input, std::unique_ptr&lt; OutputPacketCommunicator &gt; output, TimeoutLock &amp; lock, std::filesystem::path rootDir, std::function&lt; void(std::filesystem::path)&gt; formatFS, std::unordered_map&lt; std::string, std::span&lt; const uint8_t &gt; &gt; resources)  Uploader (const Uploader &amp;) = delete Uploader (Uploader &amp;&amp;) = delete void lockTimeout ()  Uploader &amp; operator= (const Uploader &amp;) = delete Uploader &amp; operator= (Uploader &amp;&amp;) = delete void start ()  ~Uploader ()"},{"location":"doxygen/classjac_1_1Uploader/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxygen/classjac_1_1Uploader/#enum-command","title":"enum Command","text":"<pre><code>enum jac::Uploader::Command {\n    READ_FILE = 0x01,\n    WRITE_FILE = 0x02,\n    DELETE_FILE = 0x03,\n    LIST_DIR = 0x04,\n    CREATE_DIR = 0x05,\n    DELETE_DIR = 0x06,\n    FORMAT_STORAGE = 0x07,\n    LIST_RESOURCES = 0x08,\n    READ_RESOURCE = 0x09,\n    HAS_MORE_DATA = 0x10,\n    LAST_DATA = 0x11,\n    OK = 0x20,\n    ERROR = 0x21,\n    NOT_FOUND = 0x22,\n    CONTINUE = 0x23,\n    LOCK_NOT_OWNED = 0x24,\n    GET_DIR_HASHES = 0x25\n};\n</code></pre>"},{"location":"doxygen/classjac_1_1Uploader/#enum-error","title":"enum Error","text":"<pre><code>enum jac::Uploader::Error {\n    UNKNOWN_COMMAND = 0x01,\n    FILE_OPEN_FAILED = 0x02,\n    FILE_DELETE_FAILED = 0x03,\n    DIR_OPEN_FAILED = 0x04,\n    DIR_CREATE_FAILED = 0x05,\n    DIR_DELETE_FAILED = 0x06,\n    INVALID_FILENAME = 0x07\n};\n</code></pre>"},{"location":"doxygen/classjac_1_1Uploader/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/classjac_1_1Uploader/#function-uploader-13","title":"function Uploader [1/3]","text":"<pre><code>inline jac::Uploader::Uploader (\n    std::unique_ptr&lt; InputPacketCommunicator &gt; input,\n    std::unique_ptr&lt; OutputPacketCommunicator &gt; output,\n    TimeoutLock &amp; lock,\n    std::filesystem::path rootDir,\n    std::function&lt; void (std::filesystem::path)&gt; formatFS,\n    std::unordered_map&lt; std::string, std::span&lt; const  uint8_t &gt; &gt; resources\n) \n</code></pre>"},{"location":"doxygen/classjac_1_1Uploader/#function-uploader-23","title":"function Uploader [2/3]","text":"<pre><code>jac::Uploader::Uploader (\n    const  Uploader &amp;\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1Uploader/#function-uploader-33","title":"function Uploader [3/3]","text":"<pre><code>jac::Uploader::Uploader (\n    Uploader &amp;&amp;\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1Uploader/#function-locktimeout","title":"function lockTimeout","text":"<pre><code>void jac::Uploader::lockTimeout () \n</code></pre>"},{"location":"doxygen/classjac_1_1Uploader/#function-operator","title":"function operator=","text":"<pre><code>Uploader &amp; jac::Uploader::operator= (\n    const  Uploader &amp;\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1Uploader/#function-operator_1","title":"function operator=","text":"<pre><code>Uploader &amp; jac::Uploader::operator= (\n    Uploader &amp;&amp;\n) = delete\n</code></pre>"},{"location":"doxygen/classjac_1_1Uploader/#function-start","title":"function start","text":"<pre><code>inline void jac::Uploader::start () \n</code></pre>"},{"location":"doxygen/classjac_1_1Uploader/#function-uploader","title":"function ~Uploader","text":"<pre><code>inline jac::Uploader::~Uploader () \n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/device/uploader.h</code></p>"},{"location":"doxygen/structjac_1_1Device_1_1MachineIO/","title":"Struct jac::Device::MachineIO","text":"<p>ClassList &gt; MachineIO</p>"},{"location":"doxygen/structjac_1_1Device_1_1MachineIO/#public-attributes","title":"Public Attributes","text":"Type Name std::unique_ptr&lt; OutputStreamCommunicator &gt; err std::unique_ptr&lt; InputStreamCommunicator &gt; in std::unique_ptr&lt; OutputStreamCommunicator &gt; out"},{"location":"doxygen/structjac_1_1Device_1_1MachineIO/#public-attributes-documentation","title":"Public Attributes Documentation","text":""},{"location":"doxygen/structjac_1_1Device_1_1MachineIO/#variable-err","title":"variable err","text":"<pre><code>std::unique_ptr&lt;OutputStreamCommunicator&gt; jac::Device&lt; Machine &gt;::MachineIO::err;\n</code></pre>"},{"location":"doxygen/structjac_1_1Device_1_1MachineIO/#variable-in","title":"variable in","text":"<pre><code>std::unique_ptr&lt;InputStreamCommunicator&gt; jac::Device&lt; Machine &gt;::MachineIO::in;\n</code></pre>"},{"location":"doxygen/structjac_1_1Device_1_1MachineIO/#variable-out","title":"variable out","text":"<pre><code>std::unique_ptr&lt;OutputStreamCommunicator&gt; jac::Device&lt; Machine &gt;::MachineIO::out;\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/device/device.h</code></p>"},{"location":"doxygen/structmbedtls__sha1__context/","title":"Struct mbedtls_sha1_context","text":"<p>ClassList &gt; mbedtls_sha1_context</p> <p>The SHA-1 context structure. More...</p> <ul> <li><code>#include &lt;sha1.h&gt;</code></li> </ul>"},{"location":"doxygen/structmbedtls__sha1__context/#public-functions","title":"Public Functions","text":"Type Name uint32_t MBEDTLS_PRIVATE (total)  uint32_t MBEDTLS_PRIVATE (state)  unsigned char MBEDTLS_PRIVATE (buffer)"},{"location":"doxygen/structmbedtls__sha1__context/#detailed-description","title":"Detailed Description","text":"<p>Warning:</p> <p>SHA-1 is considered a weak message digest and its use constitutes a security risk. We recommend considering stronger message digests instead. </p>"},{"location":"doxygen/structmbedtls__sha1__context/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/structmbedtls__sha1__context/#function-mbedtls_private-13","title":"function MBEDTLS_PRIVATE [1/3]","text":"<pre><code>uint32_t mbedtls_sha1_context::MBEDTLS_PRIVATE (\n    total\n) \n</code></pre> <p>The number of Bytes processed. </p>"},{"location":"doxygen/structmbedtls__sha1__context/#function-mbedtls_private-23","title":"function MBEDTLS_PRIVATE [2/3]","text":"<pre><code>uint32_t mbedtls_sha1_context::MBEDTLS_PRIVATE (\n    state\n) \n</code></pre> <p>The intermediate digest state. </p>"},{"location":"doxygen/structmbedtls__sha1__context/#function-mbedtls_private-33","title":"function MBEDTLS_PRIVATE [3/3]","text":"<pre><code>unsigned char mbedtls_sha1_context::MBEDTLS_PRIVATE (\n    buffer\n) \n</code></pre> <p>The data block being processed. </p> <p>The documentation for this class was generated from the following file <code>src/jac/device/util/sha1.h</code></p>"},{"location":"doxygen/dir_68267d1309a1af8e8297ef4c3efbcdba/","title":"Dir src","text":"<p>FileList &gt; src</p>"},{"location":"doxygen/dir_68267d1309a1af8e8297ef4c3efbcdba/#directories","title":"Directories","text":"Type Name dir jac <p>The documentation for this class was generated from the following file <code>src/</code></p>"},{"location":"doxygen/dir_256037ad7d0c306238e2bc4f945d341d/","title":"Dir src/jac","text":"<p>FileList &gt; jac</p>"},{"location":"doxygen/dir_256037ad7d0c306238e2bc4f945d341d/#directories","title":"Directories","text":"Type Name dir device dir features <p>The documentation for this class was generated from the following file <code>src/jac/</code></p>"},{"location":"doxygen/dir_7dcf813d97a5be213fa89559baaee677/","title":"Dir src/jac/device","text":"<p>FileList &gt; device</p>"},{"location":"doxygen/dir_7dcf813d97a5be213fa89559baaee677/#files","title":"Files","text":"Type Name file controller.cpp file controller.h file device.h file keyvalue.h file logger.cpp file logger.h file uploader.cpp file uploader.h"},{"location":"doxygen/dir_7dcf813d97a5be213fa89559baaee677/#directories","title":"Directories","text":"Type Name dir util <p>The documentation for this class was generated from the following file <code>src/jac/device/</code></p>"},{"location":"doxygen/controller_8cpp/","title":"File controller.cpp","text":"<p>FileList &gt; device &gt; controller.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"controller.h\"</code></li> </ul>"},{"location":"doxygen/controller_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace jac <p>The documentation for this class was generated from the following file <code>src/jac/device/controller.cpp</code></p>"},{"location":"doxygen/controller_8cpp_source/","title":"File controller.cpp","text":"<p>File List &gt; device &gt; controller.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"controller.h\"\n\n\nnamespace jac {\n\n\nvoid Controller::processPacket(int sender, std::span&lt;const uint8_t&gt; data) {\n    if (data.size() == 0) {\n        return;\n    }\n    auto begin = data.begin();\n    Command cmd = static_cast&lt;Command&gt;(data[0]);\n    begin++;\n\n    switch (cmd) {\n        case Command::LOCK:\n            processLock(sender);\n            return;\n        case Command::UNLOCK:\n            processUnlock(sender);\n            return;\n        case Command::FORCE_UNLOCK:\n            processForceUnlock(sender);\n            return;\n        case Command::STATUS:\n            processStatus(sender);\n            return;\n        case Command::VERSION:\n            processVersion(sender);\n            return;\n        default:\n            break;\n    }\n\n    if (!_devLock.ownedBy(sender)) {\n        Logger::debug(\"Controller: lock not owned by sender \" + std::to_string(sender));\n        auto response = this-&gt;_output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::LOCK_NOT_OWNED));\n        response-&gt;send();\n        return;\n    }\n\n    switch (cmd) {\n        case Command::START:\n            processStart(sender, std::span&lt;const uint8_t&gt;(begin, data.end()));\n            break;\n        case Command::STOP:\n            processStop(sender);\n            break;\n        case Command::CONFIG_SET:\n            processConfigSet(sender, std::span&lt;const uint8_t&gt;(begin, data.end()));\n            break;\n        case Command::CONFIG_GET:\n            processConfigGet(sender, std::span&lt;const uint8_t&gt;(begin, data.end()));\n            break;\n        case Command::CONFIG_ERASE:\n            processConfigErase(sender, std::span&lt;const uint8_t&gt;(begin, data.end()));\n        default:\n            break;\n    }\n}\n\nvoid Controller::processStart(int sender, std::span&lt;const uint8_t&gt; data) {\n    std::string filename(data.begin(), data.end());\n\n    auto result = Command::OK;\n\n    if (!_machineCtrl.startMachine(filename)) {\n        result = Command::ERROR;\n    }\n\n    auto response = this-&gt;_output-&gt;buildPacket({sender});\n    response-&gt;put(static_cast&lt;uint8_t&gt;(result));\n    response-&gt;send();\n}\n\nvoid Controller::processStop(int sender) {\n    auto result = Command::OK;\n\n    if (!_machineCtrl.stopMachine()) {\n        result = Command::ERROR;\n    }\n\n    auto response = this-&gt;_output-&gt;buildPacket({sender});\n    response-&gt;put(static_cast&lt;uint8_t&gt;(result));\n    response-&gt;send();\n}\n\nvoid Controller::processStatus(int sender) {\n    auto response = this-&gt;_output-&gt;buildPacket({sender});\n    response-&gt;put(static_cast&lt;uint8_t&gt;(Command::STATUS));\n\n    auto [running, code, status] = _machineCtrl.getMachineStatus();\n\n    response-&gt;put(static_cast&lt;uint8_t&gt;(running));\n    response-&gt;put(static_cast&lt;uint8_t&gt;(code));\n\n    response-&gt;put(std::span&lt;const uint8_t&gt;(reinterpret_cast&lt;const uint8_t*&gt;(status.data()), status.size()));\n    response-&gt;send();\n}\n\nvoid Controller::processVersion(int sender) {\n    auto response = this-&gt;_output-&gt;buildPacket({sender});\n    response-&gt;put(static_cast&lt;uint8_t&gt;(Command::VERSION));\n\n    std::string version;\n    for (auto&amp; [name, ver] : _versionInfo) {\n        version += name + \"@\" + ver + \"\\n\";\n    }\n\n    response-&gt;put(std::span&lt;const uint8_t&gt;(reinterpret_cast&lt;const uint8_t*&gt;(version.data()), version.size()));\n    response-&gt;send();\n}\n\nvoid Controller::processLock(int sender) {\n    auto response = this-&gt;_output-&gt;buildPacket({sender});\n\n    if (_devLock.ownedBy(sender)) {\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n    }\n    else if (_devLock.lock(sender)) {\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::OK));\n    }\n    else {\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n    }\n\n    response-&gt;send();\n}\n\nvoid Controller::processUnlock(int sender) {\n    auto response = this-&gt;_output-&gt;buildPacket({sender});\n\n    if (_devLock.unlock(sender)) {\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::OK));\n    }\n    else {\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n    }\n\n    response-&gt;send();\n}\n\nvoid Controller::processForceUnlock(int sender) {\n    auto response = this-&gt;_output-&gt;buildPacket({sender});\n\n    _devLock.forceUnlock();\n\n    response-&gt;put(static_cast&lt;uint8_t&gt;(Command::OK));\n}\n\nvoid Controller::processConfigSet(int sender, std::span&lt;const uint8_t&gt; data) {\n    using DataType = jac::KeyValueNamespace::DataType;\n\n    auto response = this-&gt;_output-&gt;buildPacket({sender});\n\n    // 0: namespace\n    auto stringEnd = std::find(data.begin(), data.end(), '\\0');\n    std::string nsname(data.begin(), stringEnd);\n    auto dataIt = stringEnd+1;\n    if(dataIt == data.end()) {\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n        response-&gt;send();\n        return;\n    }\n\n    auto kv = _machineCtrl.openKeyValue(nsname);\n    if(!kv) {\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n        response-&gt;send();\n        return;\n    }\n\n    // 1: name\n    stringEnd = std::find(dataIt, data.end(), '\\0');\n    std::string name(dataIt, stringEnd);\n    dataIt = stringEnd+1;\n    if(dataIt == data.end()) {\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n        response-&gt;send();\n        return;\n    }\n\n    // 2: data type\n    DataType dtype = static_cast&lt;DataType&gt;(*dataIt);\n    ++dataIt;\n\n    // 3: value\n    switch(dtype) {\n        case DataType::INT64: {\n            if(data.end() - dataIt &lt; 8) {\n                response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n                response-&gt;send();\n                return;\n            }\n            const auto intView = std::span&lt;const uint8_t&gt;(dataIt, dataIt+8);\n            kv-&gt;setInt(name, *static_cast&lt;const int64_t*&gt;(static_cast&lt;const void*&gt;(intView.data())));\n            break;\n        }\n        case DataType::FLOAT32: {\n            if(data.end() - dataIt &lt; 4) {\n                response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n                response-&gt;send();\n                return;\n            }\n            const auto floatView = std::span&lt;const uint8_t&gt;(dataIt, dataIt+4);\n            kv-&gt;setFloat(name, *static_cast&lt;const int64_t*&gt;(static_cast&lt;const void*&gt;(floatView.data())));\n            break;\n        }\n        case DataType::STRING: {\n            if(data.end() - dataIt &lt; 1) {\n                response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n                response-&gt;send();\n                return;\n            }\n            stringEnd = std::find(dataIt, data.end(), '\\0');\n            std::string value(dataIt, stringEnd);\n            kv-&gt;setString(name, value);\n            break;\n        }\n        default:\n            Logger::error(\"Unknown config data type: \" + std::to_string(dtype));\n            response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n            response-&gt;send();\n            return;\n    }\n\n    if(kv-&gt;commit()) {\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::OK));\n        _machineCtrl.emitKeyValueModified(nsname, name);\n    } else {\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n    }\n\n    response-&gt;send();\n}\n\nvoid Controller::processConfigGet(int sender, std::span&lt;const uint8_t&gt; data) {\n    using DataType = jac::KeyValueNamespace::DataType;\n\n    auto response = this-&gt;_output-&gt;buildPacket({sender});\n\n    // 0: namespace\n    auto stringEnd = std::find(data.begin(), data.end(), '\\0');\n    std::string nsname(data.begin(), stringEnd);\n    auto dataIt = stringEnd+1;\n    if(dataIt == data.end()) {\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n        response-&gt;send();\n        return;\n    }\n\n    auto kv = _machineCtrl.openKeyValue(nsname);\n    if(!kv) {\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n        response-&gt;send();\n        return;\n    }\n\n    // 1: name\n    stringEnd = std::find(dataIt, data.end(), '\\0');\n    std::string name(dataIt, stringEnd);\n    dataIt = stringEnd+1;\n    if(dataIt == data.end()) {\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n        response-&gt;send();\n        return;\n    }\n\n    // 2: data type\n    DataType dtype = static_cast&lt;DataType&gt;(*dataIt);\n    ++dataIt;\n\n    response-&gt;put(static_cast&lt;uint8_t&gt;(Command::CONFIG_GET));\n    response-&gt;put(dtype);\n\n    switch(dtype) {\n        case DataType::INT64: {\n            int64_t value = kv-&gt;getInt(name);\n            uint8_t *value_ptr = static_cast&lt;uint8_t*&gt;(static_cast&lt;void*&gt;(&amp;value));\n            std::span&lt;const uint8_t&gt; view(value_ptr, value_ptr+8);\n            response-&gt;put(view);\n            break;\n        }\n        case DataType::FLOAT32: {\n            float value = kv-&gt;getFloat(name);\n            uint8_t *value_ptr = static_cast&lt;uint8_t*&gt;(static_cast&lt;void*&gt;(&amp;value));\n            std::span&lt;const uint8_t&gt; view(value_ptr, value_ptr+4);\n            response-&gt;put(view);\n            break;\n        }\n        case DataType::STRING: {\n            auto value = kv-&gt;getString(name);\n            response-&gt;put(std::span&lt;const uint8_t&gt;(reinterpret_cast&lt;const uint8_t*&gt;(value.data()), value.size() + 1));\n            break;\n        }\n        default:\n            Logger::error(\"Unknown config data type: \" + std::to_string(dtype));\n            response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n            response-&gt;send();\n            return;\n    }\n\n    response-&gt;send();\n}\n\nvoid Controller::processConfigErase(int sender, std::span&lt;const uint8_t&gt; data) {\n    auto response = this-&gt;_output-&gt;buildPacket({sender});\n\n    // 0: namespace\n    auto stringEnd = std::find(data.begin(), data.end(), '\\0');\n    std::string nsname(data.begin(), stringEnd);\n    auto dataIt = stringEnd+1;\n    if(dataIt == data.end()) {\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n        response-&gt;send();\n        return;\n    }\n\n    auto kv = _machineCtrl.openKeyValue(nsname);\n    if(!kv) {\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n        response-&gt;send();\n        return;\n    }\n\n    // 1: name\n    stringEnd = std::find(dataIt, data.end(), '\\0');\n    std::string name(dataIt, stringEnd);\n    dataIt = stringEnd+1;\n    if(dataIt != data.end()) {\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n        response-&gt;send();\n        return;\n    }\n\n    kv-&gt;erase(name);\n\n    if(kv-&gt;commit()) {\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::OK));\n        _machineCtrl.emitKeyValueModified(nsname, name);\n    } else {\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n    }\n\n    response-&gt;send();\n}\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/controller_8h/","title":"File controller.h","text":"<p>FileList &gt; device &gt; controller.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;jac/link/mux.h&gt;</code></li> <li><code>#include &lt;jac/link/router.h&gt;</code></li> <li><code>#include &lt;jac/link/routerCommunicator.h&gt;</code></li> <li><code>#include \"util/lock.h\"</code></li> <li><code>#include \"logger.h\"</code></li> <li><code>#include \"keyvalue.h\"</code></li> <li><code>#include \"util/machineCtrl.h\"</code></li> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> </ul>"},{"location":"doxygen/controller_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/controller_8h/#classes","title":"Classes","text":"Type Name class Controller <p>The documentation for this class was generated from the following file <code>src/jac/device/controller.h</code></p>"},{"location":"doxygen/controller_8h_source/","title":"File controller.h","text":"<p>File List &gt; device &gt; controller.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;jac/link/mux.h&gt;\n#include &lt;jac/link/router.h&gt;\n#include &lt;jac/link/routerCommunicator.h&gt;\n#include \"util/lock.h\"\n\n#include \"logger.h\"\n#include \"keyvalue.h\"\n#include \"util/machineCtrl.h\"\n\n#include &lt;atomic&gt;\n#include &lt;filesystem&gt;\n#include &lt;optional&gt;\n#include &lt;sstream&gt;\n#include &lt;thread&gt;\n\n\nnamespace jac {\n\n\nclass Controller {\n    enum class Command : uint8_t {\n        START = 0x01,\n        STOP = 0x02,\n        STATUS = 0x03,\n        VERSION = 0x04,\n        LOCK = 0x10,\n        UNLOCK = 0x11,\n        FORCE_UNLOCK = 0x12,\n        OK = 0x20,\n        ERROR = 0x21,\n        LOCK_NOT_OWNED = 0x22,\n        CONFIG_SET = 0x30,\n        CONFIG_GET = 0x31,\n        CONFIG_ERASE = 0x32,\n    };\n\n    std::unique_ptr&lt;InputPacketCommunicator&gt; _input;\n    std::unique_ptr&lt;OutputPacketCommunicator&gt; _output;\n    std::thread _thread;\n    std::atomic&lt;bool&gt; _stop = false;\n\n    void processPacket(int sender, std::span&lt;const uint8_t&gt; data);\n    void processStart(int sender, std::span&lt;const uint8_t&gt; data);\n    void processStop(int sender);\n    void processStatus(int sender);\n    void processVersion(int sender);\n    void processLock(int sender);\n    void processUnlock(int sender);\n    void processForceUnlock(int sender);\n    void processConfigSet(int sender, std::span&lt;const uint8_t&gt; data);\n    void processConfigGet(int sender, std::span&lt;const uint8_t&gt; data);\n    void processConfigErase(int sender, std::span&lt;const uint8_t&gt; data);\n\n    TimeoutLock&amp; _devLock;\n    MachineCtrl&amp; _machineCtrl;\n    std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt;&amp; _versionInfo;\n\npublic:\n    Controller(std::unique_ptr&lt;InputPacketCommunicator&gt; input, std::unique_ptr&lt;OutputPacketCommunicator&gt; output,\n               TimeoutLock&amp; lock, MachineCtrl&amp; machineCtrl, std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt;&amp; versionInfo) :\n        _input(std::move(input)),\n        _output(std::move(output)),\n        _devLock(lock),\n        _machineCtrl(machineCtrl),\n        _versionInfo(versionInfo)\n    {}\n\n    ~Controller() {\n        _stop = true;\n        _input-&gt;cancelRead();\n        if (_thread.joinable()) {\n            _thread.join();\n        }\n    }\n\n    void start() {\n        _thread = std::thread([this]() {\n            while (!_stop) {\n                auto res = _input-&gt;get();\n                if (!res) {\n                    continue;\n                }\n                auto [sender, data] = *res;\n\n                _devLock.stopTimeout(sender);  // does nothing if not locked by sender\n                processPacket(sender, std::span(data.begin(), data.end()));\n                _devLock.resetTimeout(sender);  // does nothing if not locked by sender\n            }\n        });\n    }\n};\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/device_8h/","title":"File device.h","text":"<p>FileList &gt; device &gt; device.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;jac/link/mux.h&gt;</code></li> <li><code>#include &lt;jac/link/router.h&gt;</code></li> <li><code>#include &lt;jac/link/routerCommunicator.h&gt;</code></li> <li><code>#include &lt;jac/machine/values.h&gt;</code></li> <li><code>#include \"util/lock.h\"</code></li> <li><code>#include \"controller.h\"</code></li> <li><code>#include \"uploader.h\"</code></li> <li><code>#include \"logger.h\"</code></li> <li><code>#include \"util/machineCtrl.h\"</code></li> <li><code>#include \"keyvalue.h\"</code></li> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include &lt;sstream&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> </ul>"},{"location":"doxygen/device_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/device_8h/#classes","title":"Classes","text":"Type Name class Device &lt;class Machine&gt; <p>The documentation for this class was generated from the following file <code>src/jac/device/device.h</code></p>"},{"location":"doxygen/device_8h_source/","title":"File device.h","text":"<p>File List &gt; device &gt; device.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;jac/link/mux.h&gt;\n#include &lt;jac/link/router.h&gt;\n#include &lt;jac/link/routerCommunicator.h&gt;\n#include &lt;jac/machine/values.h&gt;\n#include \"util/lock.h\"\n\n#include \"controller.h\"\n#include \"uploader.h\"\n#include \"logger.h\"\n#include \"util/machineCtrl.h\"\n#include \"keyvalue.h\"\n\n#include &lt;atomic&gt;\n#include &lt;filesystem&gt;\n#include &lt;optional&gt;\n#include &lt;sstream&gt;\n#include &lt;thread&gt;\n\n\nnamespace jac {\n\n\ntemplate&lt;class Machine&gt;\nclass Device : public MachineCtrl {\n    Router _router;\n\n    std::optional&lt;Uploader&gt; _uploader;\n    std::optional&lt;Controller&gt; _controller;\n\n    TimeoutLock _lock;\n\n    std::unique_ptr&lt;Machine&gt; _machine;\n    std::vector&lt;std::function&lt;void(Machine&amp;)&gt;&gt; _onConfigureMachine;\n    std::vector&lt;std::function&lt;void(const std::string&amp;, const std::string&amp;)&gt;&gt; _onKeyValueModified;\n    std::atomic&lt;bool&gt; _machineRunning = false;\n    std::thread _machineThread;\n    std::mutex _machineMutex;\n\n    struct MachineIO {\n        std::unique_ptr&lt;InputStreamCommunicator&gt; in;\n        std::unique_ptr&lt;OutputStreamCommunicator&gt; out;\n        std::unique_ptr&lt;OutputStreamCommunicator&gt; err;\n    } _machineIO;\n\n    std::function&lt;std::string()&gt; _getMemoryStats;\n    std::function&lt;std::string()&gt; _getStorageStats;\n\n    std::filesystem::path _rootDir;\n\n    std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; _versionInfo = {\n        {\"dcore\", JAC_DCORE_VERSION}\n    };\n\n    KeyValueOpener _openKeyValueNamespace;\n\n    std::atomic&lt;int&gt; _lastExitCode = 0;\n\n    void configureMachine() {\n        _machine = std::make_unique&lt;Machine&gt;();\n\n        if (!std::filesystem::exists(_rootDir / \"data\")) {\n            std::filesystem::create_directory(_rootDir / \"data\");\n        }\n\n        if (!std::filesystem::exists(_rootDir / \"code\")) {\n            std::filesystem::create_directory(_rootDir / \"code\");\n        }\n\n        _machine-&gt;setCodeDir(_rootDir / \"code\");\n        _machine-&gt;setWorkingDir(_rootDir / \"data\");\n\n        _machine-&gt;setWatchdogHandler([this]() {\n            std::string message = \"machine watchdog triggered\\n\";\n            this-&gt;_machineIO.err-&gt;write(std::span&lt;const uint8_t&gt;(reinterpret_cast&lt;const uint8_t*&gt;(message.data()), message.size()));\n            return true;\n        });\n        _machine-&gt;setWatchdogTimeout(std::chrono::seconds(1));\n\n        for (auto&amp; f : _onConfigureMachine) {\n            f(*_machine);\n        }\n        Logger::debug(\"machine configured\");\n    }\n\n    void lockTimeout() {\n        Logger::debug(\"lock timeout\");\n\n        _uploader-&gt;lockTimeout();\n    }\npublic:\n    Device(\n        std::filesystem::path rootDir,\n        std::function&lt;std::string()&gt; getMemoryStats,\n        std::function&lt;std::string()&gt; getStorageStats,\n        std::vector&lt;std::pair&lt;std::string, std::string&gt;&gt; versionInfo,\n        std::function&lt;void(std::filesystem::path)&gt; formatFS,\n        std::unordered_map&lt;std::string, std::span&lt;const uint8_t&gt;&gt; resources,\n        KeyValueOpener openKeyValueNamespace\n    ):\n        _lock(std::chrono::seconds(1), [this] { this-&gt;lockTimeout(); }),\n        _getMemoryStats(getMemoryStats),\n        _getStorageStats(getStorageStats),\n        _rootDir(rootDir.lexically_normal()),\n        _openKeyValueNamespace(openKeyValueNamespace)\n    {\n        Logger::_errorStream = std::make_unique&lt;RouterOutputStreamCommunicator&gt;(_router, 255, std::vector&lt;int&gt;{});\n        Logger::_logStream = std::make_unique&lt;RouterOutputStreamCommunicator&gt;(_router, 253, std::vector&lt;int&gt;{});\n        Logger::_debugStream = std::make_unique&lt;RouterOutputStreamCommunicator&gt;(_router, 251, std::vector&lt;int&gt;{});\n\n        auto uploaderInput = std::make_unique&lt;RouterInputPacketCommunicator&gt;();\n        auto uploaderOutput = std::make_unique&lt;RouterOutputPacketCommunicator&gt;(_router, 1);\n        _router.subscribeChannel(1, *uploaderInput);\n\n        _uploader.emplace(\n            std::move(uploaderInput),\n            std::move(uploaderOutput),\n            _lock,\n            _rootDir,\n            std::move(formatFS),\n            std::move(resources)\n        );\n\n        auto controllerInput = std::make_unique&lt;RouterInputPacketCommunicator&gt;();\n        auto controllerOutput = std::make_unique&lt;RouterOutputPacketCommunicator&gt;(_router, 0);\n        _router.subscribeChannel(0, *controllerInput);\n\n        _controller.emplace(std::move(controllerInput), std::move(controllerOutput), _lock, *this, _versionInfo);\n\n        auto _machineIn = std::make_unique&lt;RouterInputStreamCommunicator&gt;(std::set&lt;int&gt;{});\n        _router.subscribeChannel(16, *_machineIn);\n        _machineIO.in = std::move(_machineIn);\n        _machineIO.out = std::make_unique&lt;RouterOutputStreamCommunicator&gt;(_router, 16, std::vector&lt;int&gt;{});\n        _machineIO.err = std::make_unique&lt;RouterOutputStreamCommunicator&gt;(_router, 17, std::vector&lt;int&gt;{});\n\n        for (auto&amp; [name, version] : versionInfo) {\n            _versionInfo.push_back({name, version});\n        }\n    }\n\n    Device(const Device&amp;) = delete;\n    Device&amp; operator=(const Device&amp;) = delete;\n    Device(Device&amp;&amp;) = delete;\n    Device&amp; operator=(Device&amp;&amp;) = delete;\n\n    void start() {\n        _lock.init();\n        _uploader-&gt;start();\n        _controller-&gt;start();\n    }\n\n    ~Device() {\n        stopMachine();\n    }\n\n    Router&amp; router() {\n        return _router;\n    }\n\n    TimeoutLock&amp; lock() {\n        return _lock;\n    }\n\n    MachineIO&amp; machineIO() {\n        return _machineIO;\n    }\n\n    bool startMachine(std::string path) override;\n    bool stopMachine() override;\n    std::tuple&lt;bool, int, std::string&gt; getMachineStatus() override;\n\n    const KeyValueOpener&amp; getKeyValueOpener() const {\n        return _openKeyValueNamespace;\n    }\n\n    std::unique_ptr&lt;KeyValueNamespace&gt; openKeyValue(const std::string&amp; nsname) const override {\n        return _openKeyValueNamespace(nsname);\n    }\n\n    void emitKeyValueModified(const std::string&amp; nsname, const std::string&amp; key) override {\n        for(auto&amp;f : _onKeyValueModified) {\n            f(nsname, key);\n        }\n    }\n\n    void onConfigureMachine(std::function&lt;void(Machine&amp;)&gt; f) {\n        _onConfigureMachine.push_back(f);\n    }\n\n    void onKeyValueModified(std::function&lt;void(const std::string&amp;, const std::string&amp;)&gt; f) {\n        _onKeyValueModified.push_back(f);\n    }\n};\n\ntemplate&lt;class Machine&gt;\nbool Device&lt;Machine&gt;::startMachine(std::string path) {\n    if (_machineRunning) {\n        return false;\n    }\n\n    std::scoped_lock&lt;std::mutex&gt; lock(_machineMutex);\n\n    if (_machineThread.joinable()) {\n        _machineThread.join();\n    }\n\n    _machineThread = std::thread([this, path]() {\n        Device&lt;Machine&gt;&amp; self = *this;\n\n        {\n            std::scoped_lock&lt;std::mutex&gt; lock_(self._machineMutex);\n\n            self._machineRunning = true;\n\n            Logger::log(\"Starting machine\");\n\n            self.configureMachine();\n            self._machine-&gt;initialize();\n        }\n\n        try {\n            self._machine-&gt;evalFileWithEventLoop(path);\n        }\n        catch (jac::Exception&amp; e) {\n            std::string message = \"Uncaught \" + std::string(e.what()) + \"\\n\";\n            std::string stack = e.stackTrace();\n            if (stack.size() &gt; 0 &amp;&amp; stack != \"undefined\") {\n                message += stack + \"\\n\";\n            }\n            this-&gt;_machineIO.err-&gt;write(std::span&lt;const uint8_t&gt;(reinterpret_cast&lt;const uint8_t*&gt;(message.data()), message.size()));\n        }\n        catch (const std::exception&amp; e) {\n            std::string message = \"Internal error: \" + std::string(e.what()) + \"\\n\";\n            this-&gt;_machineIO.err-&gt;write(std::span&lt;const uint8_t&gt;(reinterpret_cast&lt;const uint8_t*&gt;(message.data()), message.size()));\n            Logger::log(message);\n        }\n        catch (...) {\n            std::string message = \"Unkown internal error\\n\";\n            this-&gt;_machineIO.err-&gt;write(std::span&lt;const uint8_t&gt;(reinterpret_cast&lt;const uint8_t*&gt;(message.data()), message.size()));\n            Logger::log(message);\n        }\n\n        std::string message = \"Machine exited with code \" + std::to_string(self._machine-&gt;getExitCode()) + \"\\n\";\n        this-&gt;_machineIO.err-&gt;write(std::span&lt;const uint8_t&gt;(reinterpret_cast&lt;const uint8_t*&gt;(message.data()), message.size()));\n\n        _lastExitCode = self._machine-&gt;getExitCode();\n        _machine = nullptr;\n\n        self._machineRunning = false;\n    });\n\n    return true;\n}\n\ntemplate&lt;class Machine&gt;\nbool Device&lt;Machine&gt;::stopMachine() {\n    if (!_machineRunning) {\n        return false;\n    }\n\n    std::unique_lock&lt;std::mutex&gt; lock(_machineMutex);\n\n    _machine-&gt;kill();\n\n    if (_machineThread.joinable()) {\n        _machineThread.join();\n    }\n    _machineThread = std::thread();\n\n    return true;\n}\n\ntemplate&lt;class Machine&gt;\nstd::tuple&lt;bool, int, std::string&gt; Device&lt;Machine&gt;::getMachineStatus() {\n    bool running = _machineRunning;\n    int code = _lastExitCode;\n\n    std::stringstream oss;\n    oss &lt;&lt; \"Memory usage: \" &lt;&lt; _getMemoryStats() &lt;&lt; std::endl;\n    oss &lt;&lt; \"Storage usage: \" &lt;&lt; _getStorageStats() &lt;&lt; std::endl;\n    return { running, code, oss.str() };\n}\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/keyvalue_8h/","title":"File keyvalue.h","text":"<p>FileList &gt; device &gt; keyvalue.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"doxygen/keyvalue_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/keyvalue_8h/#classes","title":"Classes","text":"Type Name class KeyValueNamespace <p>The documentation for this class was generated from the following file <code>src/jac/device/keyvalue.h</code></p>"},{"location":"doxygen/keyvalue_8h_source/","title":"File keyvalue.h","text":"<p>File List &gt; device &gt; keyvalue.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;memory&gt;\n#include &lt;functional&gt;\n#include &lt;stdint.h&gt;\n#include &lt;string&gt;\n\nnamespace jac {\n\nclass KeyValueNamespace {\n    KeyValueNamespace(KeyValueNamespace&amp;) = delete;\n\npublic:\n    enum DataType : uint8_t {\n        INT64 = 0,\n        FLOAT32 = 1,\n        STRING = 2,\n\n        NOT_FOUND = 0xFF,\n    };\n\n    KeyValueNamespace() {}\n\n    virtual ~KeyValueNamespace() { }\n\n    virtual bool erase(const std::string&amp; name) = 0;\n    virtual std::vector&lt;std::string&gt; keys() = 0;\n\n    virtual void setInt(const std::string&amp; name, int64_t value) = 0;\n    virtual void setFloat(const std::string&amp; name, float value) = 0;\n    virtual void setString(const std::string&amp; name, const std::string&amp; value) = 0;\n\n    virtual int64_t getInt(const std::string&amp; name, int64_t def_value = 0) = 0;\n    virtual float getFloat(const std::string&amp; name, float def_value = 0.f) = 0;\n    virtual std::string getString(const std::string&amp; name, std::string def_value = \"\") = 0;\n\n    virtual DataType getType(const std::string&amp; name) = 0;\n    bool exists(const std::string&amp; name) {\n        return getType(name) != NOT_FOUND;\n    }\n\n    virtual bool commit() = 0;\n};\n\nusing KeyValueOpener = std::function&lt;std::unique_ptr&lt;KeyValueNamespace&gt;(const std::string&amp;)&gt;;\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/logger_8cpp/","title":"File logger.cpp","text":"<p>FileList &gt; device &gt; logger.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"logger.h\"</code></li> </ul>"},{"location":"doxygen/logger_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace jac <p>The documentation for this class was generated from the following file <code>src/jac/device/logger.cpp</code></p>"},{"location":"doxygen/logger_8cpp_source/","title":"File logger.cpp","text":"<p>File List &gt; device &gt; logger.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"logger.h\"\n\n\nnamespace jac {\n\n\nstd::unique_ptr&lt;OutputStreamCommunicator&gt; Logger::_errorStream;\nstd::unique_ptr&lt;OutputStreamCommunicator&gt; Logger::_logStream;\nstd::unique_ptr&lt;OutputStreamCommunicator&gt; Logger::_debugStream;\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/logger_8h/","title":"File logger.h","text":"<p>FileList &gt; device &gt; logger.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;jac/link/communicator.h&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> </ul>"},{"location":"doxygen/logger_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/logger_8h/#classes","title":"Classes","text":"Type Name struct Logger <p>The documentation for this class was generated from the following file <code>src/jac/device/logger.h</code></p>"},{"location":"doxygen/logger_8h_source/","title":"File logger.h","text":"<p>File List &gt; device &gt; logger.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;jac/link/communicator.h&gt;\n#include &lt;string&gt;\n\n\nnamespace jac {\n\n\nstruct Logger {\n    static std::unique_ptr&lt;OutputStreamCommunicator&gt; _errorStream;\n    static void error(std::string message) {\n        if (!_errorStream) {\n            return;\n        }\n        _errorStream-&gt;write(std::span&lt;const uint8_t&gt;(reinterpret_cast&lt;const uint8_t*&gt;(message.c_str()), message.size()));\n    }\n\n    static std::unique_ptr&lt;OutputStreamCommunicator&gt; _logStream;\n    static void log(std::string message) {\n        if (!_logStream) {\n            return;\n        }\n        _logStream-&gt;write(std::span&lt;const uint8_t&gt;(reinterpret_cast&lt;const uint8_t*&gt;(message.c_str()), message.size()));\n    }\n\n    static std::unique_ptr&lt;OutputStreamCommunicator&gt; _debugStream;\n    static void debug(std::string message) {\n        if (!_debugStream) {\n            return;\n        }\n        _debugStream-&gt;write(std::span&lt;const uint8_t&gt;(reinterpret_cast&lt;const uint8_t*&gt;(message.c_str()), message.size()));\n    }\n};\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/dir_5f36e4b8294e45bcbbea85a29a4cc9c0/","title":"Dir src/jac/device/util","text":"<p>FileList &gt; device &gt; util</p>"},{"location":"doxygen/dir_5f36e4b8294e45bcbbea85a29a4cc9c0/#files","title":"Files","text":"Type Name file lock.h file machineCtrl.h file sha1.h This file contains SHA-1 definitions and functions. file timeout.h <p>The documentation for this class was generated from the following file <code>src/jac/device/util/</code></p>"},{"location":"doxygen/lock_8h/","title":"File lock.h","text":"<p>FileList &gt; device &gt; util &gt; lock.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> <li><code>#include \"timeout.h\"</code></li> </ul>"},{"location":"doxygen/lock_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/lock_8h/#classes","title":"Classes","text":"Type Name class TimeoutLock <p>The documentation for this class was generated from the following file <code>src/jac/device/util/lock.h</code></p>"},{"location":"doxygen/lock_8h_source/","title":"File lock.h","text":"<p>File List &gt; device &gt; util &gt; lock.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;atomic&gt;\n#include &lt;optional&gt;\n#include \"timeout.h\"\n\n\nnamespace jac {\n\n\nclass TimeoutLock {\n    Timeout _timeout;\n    bool _locked = false;\n    int _owner = 0;\n    std::mutex _mutex;\n    int _stops = 0;\n    std::function&lt;void()&gt; _callback;\npublic:\n    TimeoutLock(std::chrono::milliseconds duration, std::function&lt;void()&gt; callback):\n        _timeout(duration),\n        _callback(callback)\n    {}\n\n    TimeoutLock(const TimeoutLock&amp;) = delete;\n    TimeoutLock(TimeoutLock&amp;&amp;) = delete;\n    TimeoutLock&amp; operator=(const TimeoutLock&amp;) = delete;\n    TimeoutLock&amp; operator=(TimeoutLock&amp;&amp;) = delete;\n\n    void init() {\n        _timeout.init();\n    }\n\n    bool lock(int who) {\n        std::scoped_lock&lt;std::mutex&gt; _(_mutex);\n\n        if (_locked &amp;&amp; _owner == who) {\n            throw std::runtime_error(\"Lock already locked, reset() should be used to reset the timeout\");\n        }\n\n        if (!_locked) {\n            _locked = true;\n            _owner = who;\n            _timeout.start([this]() {\n                std::scoped_lock&lt;std::mutex&gt; __(_mutex);\n                if (_callback) {\n                    _callback();\n                }\n                _locked = false;\n            });\n\n            return true;\n        }\n        return false;\n    }\n\n    void resetTimeout(int who) {\n        std::scoped_lock&lt;std::mutex&gt; _(_mutex);\n\n        if (!_locked || _owner != who) {\n            return;\n        }\n\n        _stops = _stops &gt; 0 ? _stops - 1 : 0;\n\n        if (_stops == 0) {\n            _timeout.reset();\n        }\n    }\n\n    void stopTimeout(int who) {\n        std::scoped_lock&lt;std::mutex&gt; _(_mutex);\n\n        if (!_locked || _owner != who) {\n            return;\n        }\n\n        _timeout.stop();\n        _stops++;\n    }\n\n    bool unlock(int who) {\n        std::scoped_lock&lt;std::mutex&gt; _(_mutex);\n\n        if (_owner != who) {\n            return false;\n        }\n\n        _timeout.stop();\n        _locked = false;\n        return true;\n    }\n\n    void forceUnlock() {\n        std::scoped_lock&lt;std::mutex&gt; _(_mutex);\n\n        _timeout.stop();\n        _locked = false;\n    }\n\n    bool ownedBy(int who) {\n        std::scoped_lock&lt;std::mutex&gt; _(_mutex);\n        return _locked &amp;&amp; _owner == who;\n    }\n\n    ~TimeoutLock() {\n        _timeout.stop();\n    }\n};\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/machineCtrl_8h/","title":"File machineCtrl.h","text":"<p>FileList &gt; device &gt; util &gt; machineCtrl.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;tuple&gt;</code></li> <li><code>#include \"../keyvalue.h\"</code></li> </ul>"},{"location":"doxygen/machineCtrl_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/machineCtrl_8h/#classes","title":"Classes","text":"Type Name class MachineCtrl <p>The documentation for this class was generated from the following file <code>src/jac/device/util/machineCtrl.h</code></p>"},{"location":"doxygen/machineCtrl_8h_source/","title":"File machineCtrl.h","text":"<p>File List &gt; device &gt; util &gt; machineCtrl.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;string&gt;\n#include &lt;tuple&gt;\n#include \"../keyvalue.h\"\n\nnamespace jac {\n\n\nclass MachineCtrl {\npublic:\n    virtual bool startMachine(std::string path) = 0;\n    virtual bool stopMachine() = 0;\n    virtual std::tuple&lt;bool, int, std::string&gt; getMachineStatus() = 0;\n\n    virtual std::unique_ptr&lt;KeyValueNamespace&gt; openKeyValue(const std::string&amp; nsname) const = 0;\n    virtual void emitKeyValueModified(const std::string&amp; nsname, const std::string&amp; key) = 0;\n};\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/sha1_8h/","title":"File sha1.h","text":"<p>FileList &gt; device &gt; util &gt; sha1.h</p> <p>Go to the source code of this file</p> <p>This file contains SHA-1 definitions and functions. More...</p> <ul> <li><code>#include &lt;stddef.h&gt;</code></li> <li><code>#include &lt;stdint.h&gt;</code></li> </ul>"},{"location":"doxygen/sha1_8h/#classes","title":"Classes","text":"Type Name struct mbedtls_sha1_context The SHA-1 context structure."},{"location":"doxygen/sha1_8h/#public-types","title":"Public Types","text":"Type Name typedef struct mbedtls_sha1_context mbedtls_sha1_context The SHA-1 context structure."},{"location":"doxygen/sha1_8h/#public-functions","title":"Public Functions","text":"Type Name int mbedtls_internal_sha1_process (mbedtls_sha1_context * ctx, const unsigned char data) SHA-1 process data block (internal use only). int mbedtls_sha1 (const unsigned char * input, size_t ilen, unsigned char output) This function calculates the SHA-1 checksum of a buffer. void mbedtls_sha1_clone (mbedtls_sha1_context * dst, const mbedtls_sha1_context * src) This function clones the state of a SHA-1 context. int mbedtls_sha1_finish (mbedtls_sha1_context * ctx, unsigned char output) This function finishes the SHA-1 operation, and writes the result to the output buffer. void mbedtls_sha1_free (mbedtls_sha1_context * ctx) This function clears a SHA-1 context. void mbedtls_sha1_init (mbedtls_sha1_context * ctx) This function initializes a SHA-1 context. int mbedtls_sha1_starts (mbedtls_sha1_context * ctx) This function starts a SHA-1 checksum calculation. int mbedtls_sha1_update (mbedtls_sha1_context * ctx, const unsigned char * input, size_t ilen) This function feeds an input buffer into an ongoing SHA-1 checksum calculation."},{"location":"doxygen/sha1_8h/#macros","title":"Macros","text":"Type Name define MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED <code>-0x006E</code> define MBEDTLS_ERR_SHA1_BAD_INPUT_DATA <code>-0x0073</code> define MBEDTLS_PRIVATE (x) <code>x</code>"},{"location":"doxygen/sha1_8h/#detailed-description","title":"Detailed Description","text":"<p>The Secure Hash Algorithm 1 (SHA-1) cryptographic hash function is defined in FIPS 180-4: Secure Hash Standard (SHS).</p> <p>Warning:</p> <p>SHA-1 is considered a weak message digest and its use constitutes a security risk. We recommend considering stronger message digests instead. </p>"},{"location":"doxygen/sha1_8h/#public-types-documentation","title":"Public Types Documentation","text":""},{"location":"doxygen/sha1_8h/#typedef-mbedtls_sha1_context","title":"typedef mbedtls_sha1_context","text":"<p>The SHA-1 context structure. <pre><code>typedef struct mbedtls_sha1_context mbedtls_sha1_context;\n</code></pre></p> <p>Warning:</p> <p>SHA-1 is considered a weak message digest and its use constitutes a security risk. We recommend considering stronger message digests instead. </p>"},{"location":"doxygen/sha1_8h/#public-functions-documentation","title":"Public Functions Documentation","text":""},{"location":"doxygen/sha1_8h/#function-mbedtls_internal_sha1_process","title":"function mbedtls_internal_sha1_process","text":"<p>SHA-1 process data block (internal use only). <pre><code>int mbedtls_internal_sha1_process (\n    mbedtls_sha1_context * ctx,\n    const unsigned char data\n) \n</code></pre></p> <p>Warning:</p> <p>SHA-1 is considered a weak message digest and its use constitutes a security risk. We recommend considering stronger message digests instead.</p> <p>Parameters:</p> <ul> <li><code>ctx</code> The SHA-1 context to use. This must be initialized. </li> <li><code>data</code> The data block being processed. This must be a readable buffer of length <code>64</code> Bytes.</li> </ul> <p>Returns:</p> <p><code>0</code> on success. </p> <p>Returns:</p> <p>A negative error code on failure. </p>"},{"location":"doxygen/sha1_8h/#function-mbedtls_sha1","title":"function mbedtls_sha1","text":"<p>This function calculates the SHA-1 checksum of a buffer. <pre><code>int mbedtls_sha1 (\n    const unsigned char * input,\n    size_t ilen,\n    unsigned char output\n) \n</code></pre></p> <p>Warning:</p> <p>SHA-1 is considered a weak message digest and its use constitutes a security risk. We recommend considering stronger message digests instead.</p> <p>Parameters:</p> <ul> <li><code>input</code> The buffer holding the input data. This must be a readable buffer of length <code>ilen</code> Bytes. </li> <li><code>ilen</code> The length of the input data <code>input</code> in Bytes. </li> <li><code>output</code> The SHA-1 checksum result. This must be a writable buffer of length <code>20</code> Bytes.</li> </ul> <p>Returns:</p> <p><code>0</code> on success. </p> <p>Returns:</p> <p>A negative error code on failure. </p>"},{"location":"doxygen/sha1_8h/#function-mbedtls_sha1_clone","title":"function mbedtls_sha1_clone","text":"<p>This function clones the state of a SHA-1 context. <pre><code>void mbedtls_sha1_clone (\n    mbedtls_sha1_context * dst,\n    const mbedtls_sha1_context * src\n) \n</code></pre></p> <p>Warning:</p> <p>SHA-1 is considered a weak message digest and its use constitutes a security risk. We recommend considering stronger message digests instead.</p> <p>Parameters:</p> <ul> <li><code>dst</code> The SHA-1 context to clone to. This must be initialized. </li> <li><code>src</code> The SHA-1 context to clone from. This must be initialized. </li> </ul>"},{"location":"doxygen/sha1_8h/#function-mbedtls_sha1_finish","title":"function mbedtls_sha1_finish","text":"<p>This function finishes the SHA-1 operation, and writes the result to the output buffer. <pre><code>int mbedtls_sha1_finish (\n    mbedtls_sha1_context * ctx,\n    unsigned char output\n) \n</code></pre></p> <p>Warning:</p> <p>SHA-1 is considered a weak message digest and its use constitutes a security risk. We recommend considering stronger message digests instead.</p> <p>Parameters:</p> <ul> <li><code>ctx</code> The SHA-1 context to use. This must be initialized and have a hash operation started. </li> <li><code>output</code> The SHA-1 checksum result. This must be a writable buffer of length <code>20</code> Bytes.</li> </ul> <p>Returns:</p> <p><code>0</code> on success. </p> <p>Returns:</p> <p>A negative error code on failure. </p>"},{"location":"doxygen/sha1_8h/#function-mbedtls_sha1_free","title":"function mbedtls_sha1_free","text":"<p>This function clears a SHA-1 context. <pre><code>void mbedtls_sha1_free (\n    mbedtls_sha1_context * ctx\n) \n</code></pre></p> <p>Warning:</p> <p>SHA-1 is considered a weak message digest and its use constitutes a security risk. We recommend considering stronger message digests instead.</p> <p>Parameters:</p> <ul> <li><code>ctx</code> The SHA-1 context to clear. This may be <code>NULL</code>, in which case this function does nothing. If it is not <code>NULL</code>, it must point to an initialized SHA-1 context. </li> </ul>"},{"location":"doxygen/sha1_8h/#function-mbedtls_sha1_init","title":"function mbedtls_sha1_init","text":"<p>This function initializes a SHA-1 context. <pre><code>void mbedtls_sha1_init (\n    mbedtls_sha1_context * ctx\n) \n</code></pre></p> <p>Warning:</p> <p>SHA-1 is considered a weak message digest and its use constitutes a security risk. We recommend considering stronger message digests instead.</p> <p>Parameters:</p> <ul> <li><code>ctx</code> The SHA-1 context to initialize. This must not be <code>NULL</code>. </li> </ul>"},{"location":"doxygen/sha1_8h/#function-mbedtls_sha1_starts","title":"function mbedtls_sha1_starts","text":"<p>This function starts a SHA-1 checksum calculation. <pre><code>int mbedtls_sha1_starts (\n    mbedtls_sha1_context * ctx\n) \n</code></pre></p> <p>Warning:</p> <p>SHA-1 is considered a weak message digest and its use constitutes a security risk. We recommend considering stronger message digests instead.</p> <p>Parameters:</p> <ul> <li><code>ctx</code> The SHA-1 context to initialize. This must be initialized.</li> </ul> <p>Returns:</p> <p><code>0</code> on success. </p> <p>Returns:</p> <p>A negative error code on failure. </p>"},{"location":"doxygen/sha1_8h/#function-mbedtls_sha1_update","title":"function mbedtls_sha1_update","text":"<p>This function feeds an input buffer into an ongoing SHA-1 checksum calculation. <pre><code>int mbedtls_sha1_update (\n    mbedtls_sha1_context * ctx,\n    const unsigned char * input,\n    size_t ilen\n) \n</code></pre></p> <p>Warning:</p> <p>SHA-1 is considered a weak message digest and its use constitutes a security risk. We recommend considering stronger message digests instead.</p> <p>Parameters:</p> <ul> <li><code>ctx</code> The SHA-1 context. This must be initialized and have a hash operation started. </li> <li><code>input</code> The buffer holding the input data. This must be a readable buffer of length <code>ilen</code> Bytes. </li> <li><code>ilen</code> The length of the input data <code>input</code> in Bytes.</li> </ul> <p>Returns:</p> <p><code>0</code> on success. </p> <p>Returns:</p> <p>A negative error code on failure. </p>"},{"location":"doxygen/sha1_8h/#macro-definition-documentation","title":"Macro Definition Documentation","text":""},{"location":"doxygen/sha1_8h/#define-mbedtls_err_error_corruption_detected","title":"define MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED","text":"<pre><code>#define MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED `-0x006E`\n</code></pre>"},{"location":"doxygen/sha1_8h/#define-mbedtls_err_sha1_bad_input_data","title":"define MBEDTLS_ERR_SHA1_BAD_INPUT_DATA","text":"<pre><code>#define MBEDTLS_ERR_SHA1_BAD_INPUT_DATA `-0x0073`\n</code></pre> <p>SHA-1 input data was malformed. </p>"},{"location":"doxygen/sha1_8h/#define-mbedtls_private","title":"define MBEDTLS_PRIVATE","text":"<pre><code>#define MBEDTLS_PRIVATE (\n    x\n) `x`\n</code></pre> <p>The documentation for this class was generated from the following file <code>src/jac/device/util/sha1.h</code></p>"},{"location":"doxygen/sha1_8h_source/","title":"File sha1.h","text":"<p>File List &gt; device &gt; util &gt; sha1.h</p> <p>Go to the documentation of this file</p> <pre><code>#ifdef JAC_DCORE_USE_MBEDTLS\n#include &lt;mbedtls/sha1.h&gt;\n#else\n\n/*\n *  Copyright The Mbed TLS Contributors\n *  SPDX-License-Identifier: Apache-2.0\n *\n *  Licensed under the Apache License, Version 2.0 (the \"License\"); you may\n *  not use this file except in compliance with the License.\n *  You may obtain a copy of the License at\n *\n *  http://www.apache.org/licenses/LICENSE-2.0\n *\n *  Unless required by applicable law or agreed to in writing, software\n *  distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n *  WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n *  See the License for the specific language governing permissions and\n *  limitations under the License.\n */\n#ifndef MBEDTLS_SHA1_H\n#define MBEDTLS_SHA1_H\n\n#include &lt;stddef.h&gt;\n#include &lt;stdint.h&gt;\n\n#define MBEDTLS_ERR_SHA1_BAD_INPUT_DATA                   -0x0073\n#define MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED -0x006E\n\n#define MBEDTLS_PRIVATE(x) x\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n// Regular implementation\n//\n\ntypedef struct mbedtls_sha1_context {\n    uint32_t MBEDTLS_PRIVATE(total)[2];          \n    uint32_t MBEDTLS_PRIVATE(state)[5];          \n    unsigned char MBEDTLS_PRIVATE(buffer)[64];   \n}\nmbedtls_sha1_context;\n\nvoid mbedtls_sha1_init(mbedtls_sha1_context *ctx);\n\nvoid mbedtls_sha1_free(mbedtls_sha1_context *ctx);\n\nvoid mbedtls_sha1_clone(mbedtls_sha1_context *dst,\n                        const mbedtls_sha1_context *src);\n\nint mbedtls_sha1_starts(mbedtls_sha1_context *ctx);\n\nint mbedtls_sha1_update(mbedtls_sha1_context *ctx,\n                        const unsigned char *input,\n                        size_t ilen);\n\nint mbedtls_sha1_finish(mbedtls_sha1_context *ctx,\n                        unsigned char output[20]);\n\nint mbedtls_internal_sha1_process(mbedtls_sha1_context *ctx,\n                                  const unsigned char data[64]);\n\nint mbedtls_sha1(const unsigned char *input,\n                 size_t ilen,\n                 unsigned char output[20]);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* mbedtls_sha1.h */\n\n#endif /* !JAC_DCORE_USE_MBEDTLS */\n</code></pre>"},{"location":"doxygen/timeout_8h/","title":"File timeout.h","text":"<p>FileList &gt; device &gt; util &gt; timeout.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;chrono&gt;</code></li> <li><code>#include &lt;condition_variable&gt;</code></li> <li><code>#include &lt;functional&gt;</code></li> <li><code>#include &lt;mutex&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> </ul>"},{"location":"doxygen/timeout_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/timeout_8h/#classes","title":"Classes","text":"Type Name class Timeout <p>The documentation for this class was generated from the following file <code>src/jac/device/util/timeout.h</code></p>"},{"location":"doxygen/timeout_8h_source/","title":"File timeout.h","text":"<p>File List &gt; device &gt; util &gt; timeout.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;chrono&gt;\n#include &lt;condition_variable&gt;\n#include &lt;functional&gt;\n#include &lt;mutex&gt;\n#include &lt;thread&gt;\n\n\nnamespace jac {\n\n\nclass Timeout {\n    std::function&lt;void()&gt; _callback;\n    std::chrono::milliseconds _duration;\n    std::chrono::steady_clock::time_point _endTime = std::chrono::steady_clock::time_point::max();\n    bool _stop = false;\n    bool _running = false;\n    std::mutex _mutex;\n    std::condition_variable _cv;\n    std::thread _thread;\npublic:\n    Timeout(std::chrono::milliseconds duration) : _duration(duration) {}\n\n    Timeout(const Timeout&amp;) = delete;\n    Timeout(Timeout&amp;&amp;) = delete;\n    Timeout&amp; operator=(const Timeout&amp;) = delete;\n    Timeout&amp; operator=(Timeout&amp;&amp;) = delete;\n\n    void init() {\n        _thread = std::thread([this]() {\n            while (!_stop) {\n                std::unique_lock&lt;std::mutex&gt; lock(_mutex);\n                if (!_running) {\n                    _cv.wait(lock);\n                    continue;\n                }\n                if (std::chrono::steady_clock::now() &gt;= _endTime) {\n                    _running = false;\n                    if (_callback) {\n                        _callback();\n                    }\n                }\n                _cv.wait_until(lock, _endTime);\n            }\n        });\n    }\n\n    void start(std::function&lt;void()&gt; callback) {\n        std::unique_lock&lt;std::mutex&gt; lock(_mutex);\n        _endTime = std::chrono::steady_clock::now() + _duration;\n        _callback = callback;\n        _running = true;\n        _cv.notify_all();\n    }\n\n    void reset() {\n        std::scoped_lock&lt;std::mutex&gt; lock(_mutex);\n        _endTime = std::chrono::steady_clock::now() + _duration;\n        _running = true;\n        _cv.notify_all();\n    }\n\n    void stop() {\n        std::unique_lock&lt;std::mutex&gt; lock(_mutex);\n        _running = false;\n        _cv.notify_all();\n    }\n\n    ~Timeout() {\n        std::unique_lock&lt;std::mutex&gt; lock(_mutex);\n        _stop = true;\n        _running = false;\n        std::this_thread::sleep_for(std::chrono::milliseconds(1));\n        lock.unlock();\n        _cv.notify_all();\n        if (_thread.joinable()) {\n            _thread.join();\n        }\n    }\n};\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/uploader_8cpp/","title":"File uploader.cpp","text":"<p>FileList &gt; device &gt; uploader.cpp</p> <p>Go to the source code of this file</p> <ul> <li><code>#include \"uploader.h\"</code></li> <li><code>#include \"logger.h\"</code></li> <li><code>#include \"util/sha1.h\"</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> <li><code>#include &lt;string&gt;</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;dirent.h&gt;</code></li> <li><code>#include &lt;optional&gt;</code></li> </ul>"},{"location":"doxygen/uploader_8cpp/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/uploader_8cpp/#classes","title":"Classes","text":"Type Name class Sha1Hasher <p>The documentation for this class was generated from the following file <code>src/jac/device/uploader.cpp</code></p>"},{"location":"doxygen/uploader_8cpp_source/","title":"File uploader.cpp","text":"<p>File List &gt; device &gt; uploader.cpp</p> <p>Go to the documentation of this file</p> <pre><code>#include \"uploader.h\"\n#include \"logger.h\"\n#include \"util/sha1.h\"\n\n#include &lt;fstream&gt;\n#include &lt;memory&gt;\n#include &lt;string&gt;\n#include &lt;filesystem&gt;\n#include &lt;dirent.h&gt;\n#include &lt;optional&gt;\n\nnamespace jac {\n\nclass Sha1Hasher {\npublic:\n    Sha1Hasher() {\n        mbedtls_sha1_init(&amp;_ctx);\n    }\n    Sha1Hasher(const Sha1Hasher&amp;) = delete;\n    ~Sha1Hasher() {\n         mbedtls_sha1_free(&amp;_ctx);\n    }\n\n    std::span&lt;const uint8_t, 20&gt; processFile(const std::filesystem::path&amp; path) {\n        _res.fill(0);\n\n        auto file = std::fstream(path, std::ios::in | std::ios::binary);\n        if (!file.is_open()) {\n            return _res;\n        }\n\n        mbedtls_sha1_starts(&amp;_ctx);\n\n        uint8_t buf[256];\n        size_t read = 0;\n        do {\n            file.read(reinterpret_cast&lt;char*&gt;(buf), sizeof(buf));;\n            read = file.gcount();\n            mbedtls_sha1_update(&amp;_ctx, buf, read);\n        } while(read &gt; 0);\n\n        mbedtls_sha1_finish(&amp;_ctx, _res.data());\n        return _res;\n    }\n\nprivate:\n    std::array&lt;uint8_t, 20&gt; _res;\n    mbedtls_sha1_context _ctx;\n};\n\nstatic std::optional&lt;std::filesystem::path&gt; getAbsolute(std::string filename, std::filesystem::path&amp; rootDir) {\n    std::filesystem::path normal = (rootDir / filename).lexically_normal();\n    auto [it, _] = std::mismatch(rootDir.begin(), rootDir.end(), normal.begin(), normal.end());\n    if (it == rootDir.end()) {\n        return normal;\n    }\n    return std::nullopt;\n}\n\n\nstatic std::optional&lt;std::pair&lt;std::vector&lt;std::string&gt;, size_t&gt;&gt; listDir(std::filesystem::path&amp; path) {\n    size_t dataSize = 0;\n    std::vector&lt;std::string&gt; files;\n    DIR *dir;\n    struct dirent *ent;\n    dir = opendir(path.c_str());\n    if (dir == NULL) {\n        return std::nullopt;\n    }\n    while ((ent = readdir(dir)) != NULL) {\n        try {\n            files.push_back(ent-&gt;d_name);\n        }\n        catch (std::bad_alloc&amp; e) {\n            closedir(dir);\n            return std::nullopt;\n        }\n        dataSize += files.back().size() + 1;\n    }\n    closedir(dir);\n    return std::make_pair(files, dataSize);\n}\n\n\nstatic bool deleteDir(std::filesystem::path&amp; path, bool onlyContents) {\n    auto list = listDir(path);\n    if (!list) {\n        return false;\n    }\n\n    for (auto&amp; file : list-&gt;first) {\n        auto fullPath = path / file;\n        if (std::filesystem::is_directory(fullPath)) {\n            if (!deleteDir(fullPath, false)) {\n                return false;\n            }\n        }\n        else if (!std::filesystem::remove(fullPath)) {\n            return false;\n        }\n    }\n\n    if (onlyContents) {\n        return true;\n    }\n    return std::filesystem::remove(path);\n}\n\nvoid Uploader::lockTimeout() {\n    _state = State::NONE;\n    _file.close();\n    _onData = nullptr;\n    _onDataComplete = nullptr;\n}\n\nbool Uploader::processPacket(int sender, std::span&lt;const uint8_t&gt; data) {\n    if (!_devLock.ownedBy(sender)) {\n        Logger::debug(\"Uploader: lock not owned by sender \" + std::to_string(sender));\n        auto response = this-&gt;_output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::LOCK_NOT_OWNED));\n        response-&gt;send();\n        return false;\n    }\n\n    if (data.size() &lt; 1) {\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Error::UNKNOWN_COMMAND));\n        response-&gt;send();\n        return false;\n    }\n    auto begin = data.begin();\n    Command cmd = static_cast&lt;Command&gt;(*begin);\n    ++begin;\n\n    if (_state == State::WAITING_FOR_DATA) {\n        bool success = false;\n        switch (cmd) {\n            case Command::HAS_MORE_DATA:\n                success = _onData(std::span&lt;const uint8_t&gt;(begin, data.end()));\n                break;\n            case Command::LAST_DATA:\n                success = _onData(std::span&lt;const uint8_t&gt;(begin, data.end()));\n                if (success) {\n                    success = (!_onDataComplete) || _onDataComplete();\n                    _state = State::NONE;\n                    _file.close();\n                    _onData = nullptr;\n                    _onDataComplete = nullptr;\n                }\n                break;\n            default:\n                auto response = _output-&gt;buildPacket({sender});\n                response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n                response-&gt;put(static_cast&lt;uint8_t&gt;(Error::UNKNOWN_COMMAND));\n                response-&gt;put(static_cast&lt;uint8_t&gt;(cmd));\n                response-&gt;send();\n                break;\n        }\n\n        if (!success) {\n            _state = State::NONE;\n            _file.close();\n            _onData = nullptr;\n            _onDataComplete = nullptr;\n        }\n        return success;\n    }\n\n    switch (cmd) {\n        case Command::READ_FILE:\n            return processReadFile(sender, std::span&lt;const uint8_t&gt;(begin, data.end()));\n        case Command::WRITE_FILE:\n            return processWriteFile(sender, std::span&lt;const uint8_t&gt;(begin, data.end()));\n        case Command::DELETE_FILE:\n            return processDeleteFile(sender, std::span&lt;const uint8_t&gt;(begin, data.end()));\n        case Command::LIST_DIR:\n            return processListDir(sender, std::span&lt;const uint8_t&gt;(begin, data.end()));\n        case Command::CREATE_DIR:\n            return processCreateDir(sender, std::span&lt;const uint8_t&gt;(begin, data.end()));\n        case Command::DELETE_DIR:\n            return processDeleteDir(sender, std::span&lt;const uint8_t&gt;(begin, data.end()));\n        case Command::FORMAT_STORAGE:\n            return processFormatStorage(sender, std::span&lt;const uint8_t&gt;(begin, data.end()));\n        case Command::GET_DIR_HASHES:\n            return processGetHashes(sender, std::span&lt;const uint8_t&gt;(begin, data.end()));\n        case Command::LIST_RESOURCES:\n            return processListResources(sender, std::span&lt;const uint8_t&gt;(begin, data.end()));\n        case Command::READ_RESOURCE:\n            return processReadResource(sender, std::span&lt;const uint8_t&gt;(begin, data.end()));\n        case Command::HAS_MORE_DATA:\n        case Command::LAST_DATA:\n        case Command::OK:\n        case Command::ERROR:\n        case Command::NOT_FOUND:\n        case Command::CONTINUE:\n        case Command::LOCK_NOT_OWNED:\n            // these commands are invalid in this context\n            break;\n    }\n\n    // unknown command\n    auto response = _output-&gt;buildPacket({sender});\n    response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n    response-&gt;put(static_cast&lt;uint8_t&gt;(Error::UNKNOWN_COMMAND));\n    response-&gt;put(static_cast&lt;uint8_t&gt;(cmd));\n    response-&gt;send();\n    return false;\n}\n\nbool Uploader::processReadFile(int sender, std::span&lt;const uint8_t&gt; data) {\n    auto begin = data.begin();\n    std::string filename(begin, data.end());\n    auto path = getAbsolute(filename, _rootDir);\n    if (!path) {\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::NOT_FOUND));\n        response-&gt;send();\n        return false;\n    }\n\n    _file = std::fstream(*path, std::ios::in | std::ios::binary);\n    if (!_file.is_open()) {\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::NOT_FOUND));\n        response-&gt;send();\n        return false;\n    }\n\n    std::vector&lt;uint8_t&gt; buff(_output-&gt;maxPacketSize({sender}) - 1);\n\n    Command prefix = Command::HAS_MORE_DATA;\n    size_t read = 1;\n    while (read &gt; 0) {\n        _file.read(reinterpret_cast&lt;char*&gt;(buff.data()), buff.size());\n        read = _file.gcount();\n\n        if (read &lt; buff.size()) {\n            prefix = Command::LAST_DATA;\n        }\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(prefix));\n        response-&gt;put(std::span(buff.data(), read));\n        response-&gt;send();\n    }\n    return true;\n}\n\nbool Uploader::processWriteFile(int sender, std::span&lt;const uint8_t&gt; data) {\n    auto filenameEnd = std::find(data.begin(), data.end(), '\\0');\n    if (filenameEnd == data.end()) {\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Error::INVALID_FILENAME));\n        response-&gt;send();\n        return false;\n    }\n\n    std::string filename(data.begin(), filenameEnd);\n    auto begin = ++filenameEnd;\n    _state = State::WAITING_FOR_DATA;\n\n    auto path = getAbsolute(filename, _rootDir);\n    if (!path) {\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::NOT_FOUND));\n        response-&gt;send();\n        return false;\n    }\n\n    _file = std::fstream(*path, std::ios::out | std::ios::binary | std::ios::trunc);\n    if (!_file.is_open()) {\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Error::FILE_OPEN_FAILED));\n        response-&gt;send();\n        return false;\n    }\n    _onData = [this, sender](std::span&lt;const uint8_t&gt; data_) {\n        _file.write(reinterpret_cast&lt;const char*&gt;(data_.data()), data_.size());\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::CONTINUE));\n        response-&gt;send();\n        return true;\n    };\n    _onDataComplete = [this, sender]() {\n        _file.sync();\n        _file.close();\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::OK));\n        response-&gt;send();\n        return true;\n    };\n\n    if (begin != data.end()) {\n        processPacket(sender, std::span&lt;const uint8_t&gt;(begin, data.end()));\n    }\n\n    return true;\n}\n\nbool Uploader::processDeleteFile(int sender, std::span&lt;const uint8_t&gt; data) {\n    auto begin = data.begin();\n    std::string filename(begin, data.end());\n    auto path = getAbsolute(filename, _rootDir);\n    if (!path) {\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::NOT_FOUND));\n        response-&gt;send();\n        return false;\n    }\n\n    bool success;\n\n    try {\n        success = !std::filesystem::is_directory(*path) &amp;&amp; std::filesystem::remove(*path);\n    }\n    catch (const std::filesystem::filesystem_error&amp; e) {\n        Logger::error(std::string(\"Failed to delete file: \") + e.what());\n        success = false;\n    }\n\n    if (success) {\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::OK));\n        response-&gt;send();\n        return true;\n    }\n    else {\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Error::FILE_DELETE_FAILED));\n        response-&gt;send();\n        return false;\n    }\n}\n\nbool Uploader::processListDir(int sender, std::span&lt;const uint8_t&gt; data) {\n    auto dataIt = std::find(data.begin(), data.end(), '\\0');\n    std::string filename(data.begin(), dataIt);\n    auto path = getAbsolute(filename, _rootDir);\n    if (!path) {\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::NOT_FOUND));\n        response-&gt;send();\n        return false;\n    }\n\n    struct {\n        bool directory = false;\n        bool size = false;\n    } flags;\n\n    for (dataIt++; dataIt &lt; data.end(); dataIt++) {\n        switch (*dataIt) {\n            case 'd':\n                flags.directory = true;\n                break;\n            case 's':\n                flags.size = true;\n                break;\n            default:\n                break;\n        }\n    }\n\n    bool isDir;\n    try {\n        isDir = std::filesystem::is_directory(*path);\n    }\n    catch (const std::filesystem::filesystem_error&amp; e) {\n        Logger::error(std::string(\"Failed to list directory: \") + e.what());\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Error::DIR_OPEN_FAILED));\n        response-&gt;send();\n        return false;\n    }\n\n    if (flags.directory || !isDir) {\n        if (std::filesystem::exists(*path)) {\n            std::string name = path-&gt;filename().string();\n            auto response = _output-&gt;buildPacket({sender});\n            response-&gt;put(static_cast&lt;uint8_t&gt;(Command::LAST_DATA));\n            response-&gt;put(static_cast&lt;uint8_t&gt;(isDir ? 'd' : 'f'));\n            response-&gt;put(std::span&lt;const uint8_t&gt;(reinterpret_cast&lt;const uint8_t*&gt;(name.data()), name.size()));\n            response-&gt;put(static_cast&lt;uint8_t&gt;('\\0'));\n            response-&gt;send();\n            return true;\n        }\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::NOT_FOUND));\n        response-&gt;send();\n        return false;\n    }\n\n    std::vector&lt;std::string&gt; files;\n    size_t dataSize = 0;\n    // for (const auto&amp; entry : std::filesystem::directory_iterator(path)) {\n    //     files.push_back(entry.path().filename().string());\n    //     dataSize += files.back().size() + 1;\n    // }\n    // XXX: std::filesystem::directory_iterator not working on esp-idf\n    auto result = listDir(*path);\n\n    if (!result) {\n        Logger::error(std::string(\"Failed to list directory\"));\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Error::DIR_OPEN_FAILED));\n        response-&gt;send();\n        return false;\n    }\n\n    std::tie(files, dataSize) = *result;\n    dataSize += files.size() * 5; // for the type byte and size\n\n    auto it = files.begin();\n    Command prefix = Command::HAS_MORE_DATA;\n    do {\n        if (dataSize &lt;= _output-&gt;maxPacketSize({sender}) - 1) {\n            prefix = Command::LAST_DATA;\n        }\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(prefix));\n        while (it != files.end() &amp;&amp; it-&gt;size() + 1 &lt;= response-&gt;space()) {\n            char type = 'f';\n            uint32_t size = 0;\n            try {\n                type = std::filesystem::is_directory(*path / *it) ? 'd' : 'f';\n            }\n            catch (const std::filesystem::filesystem_error&amp; e) {\n                Logger::error(std::string(\"Failed to check file type: \") + e.what());\n            }\n            try {\n                size = (flags.size &amp;&amp; type == 'f') ? std::filesystem::file_size(*path / *it) : 0;\n            }\n            catch (const std::filesystem::filesystem_error&amp; e) {\n                Logger::error(std::string(\"Failed to get file size: \") + e.what());\n            }\n\n            response-&gt;put(static_cast&lt;uint8_t&gt;(type));\n            response-&gt;put(std::span&lt;const uint8_t&gt;(reinterpret_cast&lt;const uint8_t*&gt;(it-&gt;data()), it-&gt;size()));\n            response-&gt;put(static_cast&lt;uint8_t&gt;('\\0'));\n            for (int i = 3; i &gt;= 0; i--) {\n                response-&gt;put(static_cast&lt;uint8_t&gt;((size &amp; (uint32_t(0xff) &lt;&lt; (i * 8))) &gt;&gt; (i * 8)));\n            }\n            dataSize -= it-&gt;size() + 6;\n            ++it;\n        }\n        response-&gt;send();\n    } while (it != files.end());\n    return true;\n}\n\nbool Uploader::processCreateDir(int sender, std::span&lt;const uint8_t&gt; data) {\n    auto begin = data.begin();\n    std::string filename(begin, data.end());\n    auto path = getAbsolute(filename, _rootDir);\n    if (!path) {\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::NOT_FOUND));\n        response-&gt;send();\n        return false;\n    }\n\n    bool success;\n\n    try {\n        if(std::filesystem::is_directory(*path)) {\n            success = true;\n        } else {\n            success = std::filesystem::create_directory(*path);\n        }\n    }\n    catch (const std::filesystem::filesystem_error&amp; e) {\n        Logger::error(std::string(\"Failed to create directory: \") + e.what());\n        success = false;\n    }\n\n    if (success) {\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::OK));\n        response-&gt;send();\n        return true;\n    }\n    else {\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Error::DIR_CREATE_FAILED));\n        response-&gt;send();\n        return false;\n    }\n}\n\nbool Uploader::processDeleteDir(int sender, std::span&lt;const uint8_t&gt; data) {\n    auto begin = data.begin();\n    std::string filename(begin, data.end());\n    auto path = getAbsolute(filename, _rootDir);\n    if (!path) {\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::NOT_FOUND));\n        response-&gt;send();\n        return false;\n    }\n\n    bool success;\n\n    try {\n        success = deleteDir(*path, path-&gt;lexically_normal() == _rootDir);\n        // XXX: std::filesystem::remove_all not working on esp-idf\n    }\n    catch (const std::filesystem::filesystem_error&amp; e) {\n        Logger::error(std::string(\"Failed to delete directory: \") + e.what());\n        success = false;\n    }\n\n    if (success) {\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::OK));\n        response-&gt;send();\n        return true;\n    }\n    else {\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Error::DIR_DELETE_FAILED));\n        response-&gt;send();\n        return false;\n    }\n}\n\nbool Uploader::processFormatStorage(int sender, std::span&lt;const uint8_t&gt; data) {\n    if (data.size() != 1 &amp;&amp; data[0] != static_cast&lt;uint8_t&gt;(Command::OK)) {\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n        response-&gt;send();\n        return false;\n    }\n\n    _formatFS(_rootDir);\n\n    auto response = _output-&gt;buildPacket({sender});\n    response-&gt;put(static_cast&lt;uint8_t&gt;(Command::OK));\n    response-&gt;send();\n\n    std::this_thread::sleep_for(std::chrono::milliseconds(200));\n    std::exit(0);\n}\n\nbool Uploader::processGetHashes(int sender, std::span&lt;const uint8_t&gt; data) {\n    auto dataIt = std::find(data.begin(), data.end(), '\\0');\n    std::string filename(data.begin(), dataIt);\n    auto path = getAbsolute(filename, _rootDir);\n    if (!path) {\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::NOT_FOUND));\n        response-&gt;send();\n        return false;\n    }\n\n    bool isDir = false;\n    try {\n        isDir = std::filesystem::is_directory(*path);\n    }\n    catch (const std::filesystem::filesystem_error&amp; e) {\n        Logger::error(std::string(\"Failed to list directory: \") + e.what());\n    }\n\n    if (!isDir) {\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Error::DIR_OPEN_FAILED));\n        response-&gt;send();\n        return false;\n    }\n\n    const size_t root_path_len = path-&gt;string().size() + 1;\n    std::vector&lt;std::string&gt; files;\n    std::vector&lt;std::filesystem::path&gt; dirs = { *path };\n\n    Sha1Hasher hasher;\n\n    while(!dirs.empty()) {\n        std::filesystem::path cur_path = dirs.back();\n        dirs.pop_back();\n        const auto cur_path_str = cur_path.string();\n        const auto rel_cur_path = cur_path_str.size() &gt; root_path_len ? cur_path_str.substr(root_path_len) : std::string();\n\n        DIR *dir = opendir(cur_path_str.c_str());\n        if (dir == NULL) {\n            continue;\n        }\n\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::HAS_MORE_DATA));\n\n        bool hasAnyData = false;\n\n        struct dirent *ent;\n        while ((ent = readdir(dir)) != NULL) {\n            try {\n                if(ent-&gt;d_type == DT_DIR) {\n                    dirs.push_back(cur_path / ent-&gt;d_name);\n                    continue;\n                } else if(ent-&gt;d_type != DT_REG) {\n                    continue;\n                }\n\n                std::string file_path;\n                if(!rel_cur_path.empty()) {\n                    file_path = rel_cur_path + \"/\" +  ent-&gt;d_name;\n                } else {\n                    file_path = std::string(ent-&gt;d_name);\n                }\n\n                if(file_path.size() + 1 &gt; response-&gt;space()) {\n                    response-&gt;send();\n                    response = _output-&gt;buildPacket({sender});\n                    response-&gt;put(static_cast&lt;uint8_t&gt;(Command::HAS_MORE_DATA));\n                }\n\n                response-&gt;put(std::span&lt;const uint8_t&gt;(reinterpret_cast&lt;const uint8_t*&gt;(file_path.c_str()), file_path.size()));\n                response-&gt;put(static_cast&lt;uint8_t&gt;('\\0'));\n\n                if(20 &gt; response-&gt;space()) {\n                    response-&gt;send();\n                    response = _output-&gt;buildPacket({sender});\n                    response-&gt;put(static_cast&lt;uint8_t&gt;(Command::HAS_MORE_DATA));\n                }\n                response-&gt;put(hasher.processFile(cur_path / ent-&gt;d_name));\n                hasAnyData = true;\n            }\n            catch (std::bad_alloc&amp; e) {\n                closedir(dir);\n                response = _output-&gt;buildPacket({sender});\n                response-&gt;put(static_cast&lt;uint8_t&gt;(Command::ERROR));\n                response-&gt;put(static_cast&lt;uint8_t&gt;(Error::FILE_OPEN_FAILED));\n                response-&gt;send();\n                return false;\n            }\n        }\n        closedir(dir);\n\n        if(hasAnyData) {\n            response-&gt;send();\n        }\n    }\n\n    auto response = _output-&gt;buildPacket({sender});\n    response-&gt;put(static_cast&lt;uint8_t&gt;(Command::LAST_DATA));\n    response-&gt;send();\n    return true;\n}\n\nbool Uploader::processListResources(int sender, std::span&lt;const uint8_t&gt; data) {\n    auto response = this-&gt;_output-&gt;buildPacket({sender});\n    response-&gt;put(static_cast&lt;uint8_t&gt;(Command::LAST_DATA));\n\n    std::string out;\n    for (auto&amp; [name, rdata] : _resources) {\n        response-&gt;put(std::span&lt;const uint8_t&gt;(reinterpret_cast&lt;const uint8_t*&gt;(name.data()), name.size()));\n        response-&gt;put(static_cast&lt;uint8_t&gt;('\\0'));\n        for (int i = 3; i &gt;= 0; i--) {\n            response-&gt;put(static_cast&lt;uint8_t&gt;((rdata.size() &amp; (uint32_t(0xff) &lt;&lt; (i * 8))) &gt;&gt; (i * 8)));\n        }\n    }\n\n    response-&gt;send();\n\n    return true;\n}\n\nbool Uploader::processReadResource(int sender, std::span&lt;const uint8_t&gt; data) {\n    auto begin = data.begin();\n    std::string resource(begin, data.end());\n\n    auto it = _resources.find(resource);\n    if (it == _resources.end()) {\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(Command::NOT_FOUND));\n        response-&gt;send();\n        return false;\n    }\n\n    std::span&lt;const uint8_t&gt; dataSpan = it-&gt;second;\n\n    size_t windowSize = _output-&gt;maxPacketSize({sender}) - 1;\n\n    Command prefix = Command::HAS_MORE_DATA;\n    size_t sent = std::max(dataSpan.size(), std::size_t(1));\n    while (sent &gt; 0) {\n        if (dataSpan.size() &lt;= windowSize) {\n            prefix = Command::LAST_DATA;\n        }\n\n        auto response = _output-&gt;buildPacket({sender});\n        response-&gt;put(static_cast&lt;uint8_t&gt;(prefix));\n        sent = response-&gt;put(dataSpan);\n        Logger::debug(\"Read \" + std::to_string(sent) + \" bytes\");\n        response-&gt;send();\n\n        dataSpan = dataSpan.subspan(sent);\n    }\n    return true;\n}\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/uploader_8h/","title":"File uploader.h","text":"<p>FileList &gt; device &gt; uploader.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;jac/link/router.h&gt;</code></li> <li><code>#include &lt;jac/link/routerCommunicator.h&gt;</code></li> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;deque&gt;</code></li> <li><code>#include &lt;filesystem&gt;</code></li> <li><code>#include &lt;fstream&gt;</code></li> <li><code>#include &lt;memory.h&gt;</code></li> <li><code>#include \"util/lock.h\"</code></li> </ul>"},{"location":"doxygen/uploader_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/uploader_8h/#classes","title":"Classes","text":"Type Name class Uploader <p>The documentation for this class was generated from the following file <code>src/jac/device/uploader.h</code></p>"},{"location":"doxygen/uploader_8h_source/","title":"File uploader.h","text":"<p>File List &gt; device &gt; uploader.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;jac/link/router.h&gt;\n#include &lt;jac/link/routerCommunicator.h&gt;\n\n#include &lt;atomic&gt;\n#include &lt;deque&gt;\n#include &lt;filesystem&gt;\n#include &lt;fstream&gt;\n#include &lt;memory.h&gt;\n\n#include \"util/lock.h\"\n\n\nnamespace jac {\n\n\nclass Uploader {\npublic:\n    enum class Command : uint8_t {\n        READ_FILE = 0x01,\n        WRITE_FILE = 0x02,\n        DELETE_FILE = 0x03,\n        LIST_DIR = 0x04,\n        CREATE_DIR = 0x05,\n        DELETE_DIR = 0x06,\n        FORMAT_STORAGE = 0x07,\n        LIST_RESOURCES = 0x08,\n        READ_RESOURCE = 0x09,\n        HAS_MORE_DATA = 0x10,\n        LAST_DATA = 0x11,\n        OK = 0x20,\n        ERROR = 0x21,\n        NOT_FOUND = 0x22,\n        CONTINUE = 0x23,\n        LOCK_NOT_OWNED = 0x24,\n        GET_DIR_HASHES = 0x25,\n    };\n\n    enum class Error : uint8_t {\n        UNKNOWN_COMMAND = 0x01,\n        FILE_OPEN_FAILED = 0x02,\n        FILE_DELETE_FAILED = 0x03,\n        DIR_OPEN_FAILED = 0x04,\n        DIR_CREATE_FAILED = 0x05,\n        DIR_DELETE_FAILED = 0x06,\n        INVALID_FILENAME = 0x07,\n    };\nprivate:\n    enum class State {\n        NONE,\n        WAITING_FOR_DATA\n    };\n\n    State _state = State::NONE;\n    std::fstream _file;\n    std::function&lt;bool(std::span&lt;const uint8_t&gt;)&gt; _onData;\n    std::function&lt;bool()&gt; _onDataComplete;\n\n    std::unique_ptr&lt;InputPacketCommunicator&gt; _input;\n    std::unique_ptr&lt;OutputPacketCommunicator&gt; _output;\n\n    bool processPacket(int sender, std::span&lt;const uint8_t&gt; data);\n    bool processReadFile(int sender, std::span&lt;const uint8_t&gt; data);\n    bool processWriteFile(int sender, std::span&lt;const uint8_t&gt; data);\n    bool processDeleteFile(int sender, std::span&lt;const uint8_t&gt; data);\n    bool processListDir(int sender, std::span&lt;const uint8_t&gt; data);\n    bool processCreateDir(int sender, std::span&lt;const uint8_t&gt; data);\n    bool processDeleteDir(int sender, std::span&lt;const uint8_t&gt; data);\n    bool processFormatStorage(int sender, std::span&lt;const uint8_t&gt; data);\n    bool processGetHashes(int sender, std::span&lt;const uint8_t&gt; data);\n    bool processListResources(int sender, std::span&lt;const uint8_t&gt; data);\n    bool processReadResource(int sender, std::span&lt;const uint8_t&gt; data);\n\n    std::thread _thread;\n    std::atomic&lt;bool&gt; _stop = false;\n\n    TimeoutLock&amp; _devLock;\n\n    std::filesystem::path _rootDir;\n    std::function&lt;void(std::filesystem::path)&gt; _formatFS;\n\n    std::unordered_map&lt;std::string, std::span&lt;const uint8_t&gt;&gt; _resources;\npublic:\n    Uploader(\n        std::unique_ptr&lt;InputPacketCommunicator&gt; input,\n        std::unique_ptr&lt;OutputPacketCommunicator&gt; output,\n        TimeoutLock&amp; lock,\n        std::filesystem::path rootDir,\n        std::function&lt;void(std::filesystem::path)&gt; formatFS,\n        std::unordered_map&lt;std::string, std::span&lt;const uint8_t&gt;&gt; resources\n    ):\n        _input(std::move(input)),\n        _output(std::move(output)),\n        _devLock(lock),\n        _rootDir(std::move(rootDir)),\n        _formatFS(std::move(formatFS)),\n        _resources(std::move(resources))\n    {}\n\n    Uploader(const Uploader&amp;) = delete;\n    Uploader(Uploader&amp;&amp;) = delete;\n    Uploader&amp; operator=(const Uploader&amp;) = delete;\n    Uploader&amp; operator=(Uploader&amp;&amp;) = delete;\n\n    void lockTimeout();\n\n    void start() {\n        _thread = std::thread([this]() {\n            while (!_stop) {\n                auto res = _input-&gt;get();\n                if (!res) {\n                    continue;\n                }\n                auto [sender, data] = *res;\n\n                _devLock.stopTimeout(sender);  // does nothing if not locked by sender\n                processPacket(sender, std::span&lt;const uint8_t&gt;(data.begin(), data.end()));\n                _devLock.resetTimeout(sender);  // does nothing if not locked by sender\n            }\n        });\n    }\n\n    ~Uploader() {\n        _stop = true;\n        _input-&gt;cancelRead();\n        if (_thread.joinable()) {\n            _thread.join();\n        }\n    }\n};\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/dir_6f95e06b732314161804ab1ef73c9681/","title":"Dir src/jac/features","text":"<p>FileList &gt; features</p>"},{"location":"doxygen/dir_6f95e06b732314161804ab1ef73c9681/#files","title":"Files","text":"Type Name file keyvalueFeature.h"},{"location":"doxygen/dir_6f95e06b732314161804ab1ef73c9681/#directories","title":"Directories","text":"Type Name dir util <p>The documentation for this class was generated from the following file <code>src/jac/features/</code></p>"},{"location":"doxygen/keyvalueFeature_8h/","title":"File keyvalueFeature.h","text":"<p>FileList &gt; features &gt; keyvalueFeature.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;jac/machine/machine.h&gt;</code></li> <li><code>#include &lt;jac/machine/functionFactory.h&gt;</code></li> <li><code>#include &lt;jac/machine/class.h&gt;</code></li> <li><code>#include &lt;jac/device/keyvalue.h&gt;</code></li> <li><code>#include &lt;noal_func.h&gt;</code></li> <li><code>#include &lt;memory&gt;</code></li> </ul>"},{"location":"doxygen/keyvalueFeature_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/keyvalueFeature_8h/#classes","title":"Classes","text":"Type Name class KeyValueFeature &lt;class Next&gt; struct KeyValueNamespaceProtoBuilder <p>The documentation for this class was generated from the following file <code>src/jac/features/keyvalueFeature.h</code></p>"},{"location":"doxygen/keyvalueFeature_8h_source/","title":"File keyvalueFeature.h","text":"<p>File List &gt; features &gt; keyvalueFeature.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;jac/machine/machine.h&gt;\n#include &lt;jac/machine/functionFactory.h&gt;\n#include &lt;jac/machine/class.h&gt;\n#include &lt;jac/device/keyvalue.h&gt;\n\n#include &lt;noal_func.h&gt;\n#include &lt;memory&gt;\n\n\nnamespace jac {\n\n\nstruct KeyValueNamespaceProtoBuilder : public jac::ProtoBuilder::Opaque&lt;jac::KeyValueNamespace&gt;, public jac::ProtoBuilder::Properties {\n    static jac::Value get(jac::ContextRef ctx, jac::ValueWeak thisVal, std::string key) {\n        using namespace jac;\n        using DT = KeyValueNamespace::DataType;\n\n        auto&amp; self = *KeyValueNamespaceProtoBuilder::getOpaque(ctx, thisVal);\n        switch(self.getType(key)) {\n            case DT::INT64:\n                return Value::from(ctx, self.getInt(key));\n            case DT::FLOAT32:\n                return Value::from(ctx, self.getFloat(key));\n            case DT::STRING:\n                return Value::from(ctx, self.getString(key));\n            default:\n                return Value::null(ctx);\n        }\n    }\n\n    static void addProperties(JSContext* ctx, jac::Object proto) {\n        jac::FunctionFactory ff(ctx);\n\n        proto.defineProperty(\"get\", ff.newFunctionThis(std::function(&amp;get)), jac::PropFlags::Enumerable);\n\n        proto.defineProperty(\"getString\", ff.newFunctionThis([](jac::ContextRef ctx_, jac::ValueWeak thisVal, std::string key) {\n            auto res = get(ctx_, thisVal, key);\n            if(JS_IsString(res.getVal())) {\n                return res;\n            }\n            return jac::Value::null(ctx_);\n        }), jac::PropFlags::Enumerable);\n\n        proto.defineProperty(\"getNumber\", ff.newFunctionThis([](jac::ContextRef ctx_, jac::ValueWeak thisVal, std::string key) {\n            auto res = get(ctx_, thisVal, key);\n            if(JS_IsNumber(res.getVal())) {\n                return res;\n            }\n            return jac::Value::null(ctx_);\n        }), jac::PropFlags::Enumerable);\n\n        proto.defineProperty(\"set\", ff.newFunctionThis([](jac::ContextRef ctx_, jac::ValueWeak thisVal, std::string key, jac::Value value) {\n            using namespace jac;\n\n            if(key.length() &gt; 15) {\n                throw Exception::create(Exception::Type::TypeError, \"key is too long (max 15 chars)\");\n            }\n\n            auto&amp; self = *KeyValueNamespaceProtoBuilder::getOpaque(ctx_, thisVal);\n            auto tag = JS_VALUE_GET_TAG(value.getVal());\n            if(tag == JS_TAG_INT) {\n                self.setInt(key, value.to&lt;int64_t&gt;());\n            } else if(JS_TAG_IS_FLOAT64(tag)) {\n                self.setFloat(key, value.to&lt;double&gt;());\n            } else if(tag == JS_TAG_STRING) {\n                self.setString(key, value.to&lt;std::string&gt;());\n            } else {\n                throw Exception::create(Exception::Type::TypeError, \"value has wrong type\");\n            }\n        }), jac::PropFlags::Enumerable);\n\n        proto.defineProperty(\"erase\", ff.newFunctionThis([](jac::ContextRef ctx_, jac::ValueWeak thisVal, std::string key) {\n            auto&amp; self = *KeyValueNamespaceProtoBuilder::getOpaque(ctx_, thisVal);\n            self.erase(key);\n        }), jac::PropFlags::Enumerable);\n\n        proto.defineProperty(\"exists\", ff.newFunctionThis([](jac::ContextRef ctx_, jac::ValueWeak thisVal, std::string key) {\n            auto&amp; self = *KeyValueNamespaceProtoBuilder::getOpaque(ctx_, thisVal);\n            return self.exists(key);\n        }), jac::PropFlags::Enumerable);\n\n        proto.defineProperty(\"commit\", ff.newFunctionThis([](jac::ContextRef ctx_, jac::ValueWeak thisVal) {\n            using namespace jac;\n            auto&amp; self = *KeyValueNamespaceProtoBuilder::getOpaque(ctx_, thisVal);\n            if(!self.commit()) {\n                throw Exception::create(Exception::Type::InternalError, \"NVS saving failed\");\n            }\n        }), jac::PropFlags::Enumerable);\n\n        proto.defineProperty(\"keys\", ff.newFunctionThis([](jac::ContextRef ctx_, jac::ValueWeak thisVal) {\n            auto&amp; self = *KeyValueNamespaceProtoBuilder::getOpaque(ctx_, thisVal);\n            auto keys = self.keys();\n            auto arr = jac::Array::create(ctx_);\n\n            auto atom = jac::Atom::create(ctx_, \"push\");\n            for(const auto&amp; key : keys) {\n                arr.invoke&lt;void&gt;(atom, key);\n            }\n            return arr;\n        }), jac::PropFlags::Enumerable);\n    }\n};\n\n\ntemplate&lt;class Next&gt;\nclass KeyValueFeature : public Next {\npublic:\n    using KvClass = jac::Class&lt;KeyValueNamespaceProtoBuilder&gt;;\n\n    jac::KeyValueOpener kvOpener;\n\n    KeyValueFeature() {\n        KvClass::init(\"KeyValueNamespace\");\n    }\n\n    void initialize() {\n        using namespace jac;\n\n        Next::initialize();\n\n        FunctionFactory ff(this-&gt;context());\n        Module&amp; mod = this-&gt;newModule(\"keyvalue\");\n\n        mod.addExport(\"open\", ff.newFunction(noal::function([this](std::string nsname) {\n            if(!kvOpener) {\n                throw Exception::create(Exception::Type::InternalError, \"KeyValueFeature not set up\");\n            }\n\n            if(nsname.length() &gt; 15) {\n                throw Exception::create(Exception::Type::TypeError, \"namespace is too long (max 15 chars)\");\n            }\n\n            if(nsname == \"wifi_net\") {\n                throw Exception::create(Exception::Type::InternalError, \"this namespace is protected\");\n            }\n\n            auto nsHandle = kvOpener(nsname);\n            if(!nsHandle) {\n                throw Exception::create(Exception::Type::InternalError, \"failed to open namespace\");\n            }\n            return KvClass::createInstance(this-&gt;context(), nsHandle.release());\n        })));\n    }\n};\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/dir_8745a1fa89e3088deda48338e7669502/","title":"Dir src/jac/features/util","text":"<p>FileList &gt; features &gt; util</p>"},{"location":"doxygen/dir_8745a1fa89e3088deda48338e7669502/#files","title":"Files","text":"Type Name file linkIo.h <p>The documentation for this class was generated from the following file <code>src/jac/features/util/</code></p>"},{"location":"doxygen/linkIo_8h/","title":"File linkIo.h","text":"<p>FileList &gt; features &gt; util &gt; linkIo.h</p> <p>Go to the source code of this file</p> <ul> <li><code>#include &lt;jac/link/communicator.h&gt;</code></li> <li><code>#include &lt;jac/machine/machine.h&gt;</code></li> <li><code>#include &lt;jac/features/types/streams.h&gt;</code></li> <li><code>#include &lt;atomic&gt;</code></li> <li><code>#include &lt;thread&gt;</code></li> </ul>"},{"location":"doxygen/linkIo_8h/#namespaces","title":"Namespaces","text":"Type Name namespace jac"},{"location":"doxygen/linkIo_8h/#classes","title":"Classes","text":"Type Name class LinkReadable &lt;class Machine&gt; class LinkWritable <p>The documentation for this class was generated from the following file <code>src/jac/features/util/linkIo.h</code></p>"},{"location":"doxygen/linkIo_8h_source/","title":"File linkIo.h","text":"<p>File List &gt; features &gt; util &gt; linkIo.h</p> <p>Go to the documentation of this file</p> <pre><code>#pragma once\n\n#include &lt;jac/link/communicator.h&gt;\n#include &lt;jac/machine/machine.h&gt;\n#include &lt;jac/features/types/streams.h&gt;\n\n#include &lt;atomic&gt;\n#include &lt;thread&gt;\n\n\nnamespace jac {\n\n\nclass LinkWritable : public Writable {\n    jac::OutputStreamCommunicator* _comm;\npublic:\n    LinkWritable(jac::OutputStreamCommunicator* comm): _comm(std::move(comm)) {}\n\n    void write(std::string data) override {\n        _comm-&gt;write(std::span&lt;const uint8_t&gt;(reinterpret_cast&lt;const uint8_t*&gt;(data.data()), data.size()));\n    }\n};\n\ntemplate&lt;class Machine&gt;\nclass LinkReadable : public Readable {\n    Machine* _machine;\n    jac::InputStreamCommunicator* _comm;\n    std::thread _thread;\n    std::atomic&lt;bool&gt; _running = false;\n\n    bool startRead(auto callback) {\n        if (_running) {\n            return false;\n        }\n        if (_thread.joinable()) {\n            _thread.join();\n        }\n        _running = true;\n\n        _thread = std::thread(std::move(callback));\n\n        return true;\n    }\npublic:\n    LinkReadable(Machine* machine, jac::InputStreamCommunicator* comm): _machine(machine), _comm(std::move(comm)) {}\n    LinkReadable(LinkReadable&amp;) = delete;\n    LinkReadable(LinkReadable&amp;&amp;) = delete;\n\n    bool get(std::function&lt;void(char)&gt; callback) override {\n        return startRead([this, callback = std::move(callback)]() mutable {\n            int res = _comm-&gt;get();\n\n            if (res != 0) {\n                _machine-&gt;scheduleEvent([callback = std::move(callback), res]() mutable {\n                    callback(static_cast&lt;char&gt;(res));\n                });\n            }\n\n            _running = false;\n        });\n    }\n\n    bool read(std::function&lt;void(std::string)&gt; callback) override {\n        return startRead([this, callback = std::move(callback)]() mutable {\n            std::string buffer;\n            buffer.resize(256);\n\n            auto count = _comm-&gt;read(std::span&lt;uint8_t&gt;(reinterpret_cast&lt;uint8_t*&gt;(buffer.data()), buffer.size()));\n\n            buffer.resize(count);\n            _machine-&gt;scheduleEvent([callback = std::move(callback), buffer = std::move(buffer)]() mutable {\n                callback(std::move(buffer));\n            });\n\n            _running = false;\n        });\n    }\n\n    ~LinkReadable() override {\n        if (_running) {\n            _comm-&gt;cancelRead();\n        }\n        if (_thread.joinable()) {\n            _thread.join();\n        }\n    }\n};\n\n\n} // namespace jac\n</code></pre>"},{"location":"doxygen/namespaces/","title":"Namespace List","text":"<p>Here is a list of all namespaces with brief descriptions:</p> <ul> <li>namespace jac <ul> <li>namespace ProtoBuilder </li> </ul> </li> </ul>"},{"location":"doxygen/classes/","title":"Class Index","text":""},{"location":"doxygen/classes/#c","title":"c","text":"<ul> <li>Controller (jac)</li> </ul>"},{"location":"doxygen/classes/#d","title":"d","text":"<ul> <li>Device (jac)</li> </ul>"},{"location":"doxygen/classes/#k","title":"k","text":"<ul> <li>KeyValueFeature (jac)</li> <li>KeyValueNamespace (jac)</li> <li>KeyValueNamespaceProtoBuilder (jac)</li> </ul>"},{"location":"doxygen/classes/#l","title":"l","text":"<ul> <li>LinkReadable (jac)</li> <li>LinkWritable (jac)</li> <li>Logger (jac)</li> </ul>"},{"location":"doxygen/classes/#m","title":"m","text":"<ul> <li>MachineCtrl (jac)</li> <li>MachineIO</li> <li>mbedtls_sha1_context</li> </ul>"},{"location":"doxygen/classes/#s","title":"s","text":"<ul> <li>Sha1Hasher (jac)</li> </ul>"},{"location":"doxygen/classes/#t","title":"t","text":"<ul> <li>Timeout (jac)</li> <li>TimeoutLock (jac)</li> </ul>"},{"location":"doxygen/classes/#u","title":"u","text":"<ul> <li>Uploader (jac)</li> </ul>"},{"location":"doxygen/hierarchy/","title":"Class Hierarchy","text":"<p>This inheritance list is sorted roughly, but not completely, alphabetically:</p> <ul> <li>class jac::Controller </li> <li>class jac::MachineCtrl <ul> <li>class jac::Device </li> </ul> </li> <li>class jac::KeyValueNamespace </li> <li>class jac::Sha1Hasher </li> <li>class jac::Timeout </li> <li>class jac::TimeoutLock </li> <li>class jac::Uploader </li> <li>struct jac::Logger </li> <li>struct jac::Device::MachineIO </li> <li>struct mbedtls_sha1_context The SHA-1 context structure. </li> <li>class Next <ul> <li>class jac::KeyValueFeature </li> </ul> </li> <li>class Readable <ul> <li>class jac::LinkReadable </li> </ul> </li> <li>class Writable <ul> <li>class jac::LinkWritable </li> </ul> </li> <li>class jac::ProtoBuilder::Opaque&lt; jac::KeyValueNamespace &gt; <ul> <li>struct jac::KeyValueNamespaceProtoBuilder </li> </ul> </li> <li>class jac::ProtoBuilder::Properties <ul> <li>struct jac::KeyValueNamespaceProtoBuilder </li> </ul> </li> </ul>"},{"location":"doxygen/modules/","title":"Modules","text":"<p>No modules found.</p>"},{"location":"doxygen/pages/","title":"Related Pages","text":"<p>Here is a list of all related documentation pages:</p>"},{"location":"doxygen/class_members/","title":"Class Members","text":""},{"location":"doxygen/class_members/#a","title":"a","text":"<ul> <li>addProperties (jac::KeyValueNamespaceProtoBuilder)</li> </ul>"},{"location":"doxygen/class_members/#c","title":"c","text":"<ul> <li>Command (jac::Controller, jac::Uploader)</li> <li>Controller (jac::Controller)</li> <li>configureMachine (jac::Device)</li> <li>commit (jac::KeyValueNamespace)</li> </ul>"},{"location":"doxygen/class_members/#d","title":"d","text":"<ul> <li>Device (jac::Device)</li> <li>DataType (jac::KeyValueNamespace)</li> <li>debug (jac::Logger)</li> </ul>"},{"location":"doxygen/class_members/#e","title":"e","text":"<ul> <li>emitKeyValueModified (jac::Device, jac::MachineCtrl)</li> <li>erase (jac::KeyValueNamespace)</li> <li>exists (jac::KeyValueNamespace)</li> <li>error (jac::Logger)</li> <li>Error (jac::Uploader)</li> <li>err (jac::Device::MachineIO)</li> </ul>"},{"location":"doxygen/class_members/#f","title":"f","text":"<ul> <li>forceUnlock (jac::TimeoutLock)</li> </ul>"},{"location":"doxygen/class_members/#g","title":"g","text":"<ul> <li>getKeyValueOpener (jac::Device)</li> <li>getMachineStatus (jac::Device, jac::MachineCtrl)</li> <li>getFloat (jac::KeyValueNamespace)</li> <li>getInt (jac::KeyValueNamespace)</li> <li>getString (jac::KeyValueNamespace)</li> <li>getType (jac::KeyValueNamespace)</li> <li>get (jac::KeyValueNamespaceProtoBuilder, jac::LinkReadable)</li> </ul>"},{"location":"doxygen/class_members/#i","title":"i","text":"<ul> <li>initialize (jac::KeyValueFeature)</li> <li>init (jac::Timeout, jac::TimeoutLock)</li> <li>in (jac::Device::MachineIO)</li> </ul>"},{"location":"doxygen/class_members/#k","title":"k","text":"<ul> <li>KeyValueFeature (jac::KeyValueFeature)</li> <li>KvClass (jac::KeyValueFeature)</li> <li>kvOpener (jac::KeyValueFeature)</li> <li>KeyValueNamespace (jac::KeyValueNamespace)</li> <li>keys (jac::KeyValueNamespace)</li> </ul>"},{"location":"doxygen/class_members/#l","title":"l","text":"<ul> <li>lock (jac::Device, jac::TimeoutLock)</li> <li>lockTimeout (jac::Device, jac::Uploader)</li> <li>LinkReadable (jac::LinkReadable)</li> <li>LinkWritable (jac::LinkWritable)</li> <li>log (jac::Logger)</li> </ul>"},{"location":"doxygen/class_members/#m","title":"m","text":"<ul> <li>machineIO (jac::Device)</li> <li>MBEDTLS_PRIVATE (mbedtls_sha1_context)</li> </ul>"},{"location":"doxygen/class_members/#o","title":"o","text":"<ul> <li>onConfigureMachine (jac::Device)</li> <li>onKeyValueModified (jac::Device)</li> <li>openKeyValue (jac::Device, jac::MachineCtrl)</li> <li>operator= (jac::Device, jac::Timeout, jac::TimeoutLock, jac::Uploader)</li> <li>ownedBy (jac::TimeoutLock)</li> <li>out (jac::Device::MachineIO)</li> </ul>"},{"location":"doxygen/class_members/#p","title":"p","text":"<ul> <li>processConfigErase (jac::Controller)</li> <li>processConfigGet (jac::Controller)</li> <li>processConfigSet (jac::Controller)</li> <li>processForceUnlock (jac::Controller)</li> <li>processLock (jac::Controller)</li> <li>processPacket (jac::Controller, jac::Uploader)</li> <li>processStart (jac::Controller)</li> <li>processStatus (jac::Controller)</li> <li>processStop (jac::Controller)</li> <li>processUnlock (jac::Controller)</li> <li>processVersion (jac::Controller)</li> <li>processFile (jac::Sha1Hasher)</li> <li>processCreateDir (jac::Uploader)</li> <li>processDeleteDir (jac::Uploader)</li> <li>processDeleteFile (jac::Uploader)</li> <li>processFormatStorage (jac::Uploader)</li> <li>processGetHashes (jac::Uploader)</li> <li>processListDir (jac::Uploader)</li> <li>processListResources (jac::Uploader)</li> <li>processReadFile (jac::Uploader)</li> <li>processReadResource (jac::Uploader)</li> <li>processWriteFile (jac::Uploader)</li> </ul>"},{"location":"doxygen/class_members/#r","title":"r","text":"<ul> <li>router (jac::Device)</li> <li>read (jac::LinkReadable)</li> <li>reset (jac::Timeout)</li> <li>resetTimeout (jac::TimeoutLock)</li> </ul>"},{"location":"doxygen/class_members/#s","title":"s","text":"<ul> <li>start (jac::Controller, jac::Device, jac::Timeout, jac::Uploader)</li> <li>startMachine (jac::Device, jac::MachineCtrl)</li> <li>stopMachine (jac::Device, jac::MachineCtrl)</li> <li>setFloat (jac::KeyValueNamespace)</li> <li>setInt (jac::KeyValueNamespace)</li> <li>setString (jac::KeyValueNamespace)</li> <li>startRead (jac::LinkReadable)</li> <li>Sha1Hasher (jac::Sha1Hasher)</li> <li>stop (jac::Timeout)</li> <li>stopTimeout (jac::TimeoutLock)</li> <li>State (jac::Uploader)</li> </ul>"},{"location":"doxygen/class_members/#t","title":"t","text":"<ul> <li>Timeout (jac::Timeout)</li> <li>TimeoutLock (jac::TimeoutLock)</li> </ul>"},{"location":"doxygen/class_members/#u","title":"u","text":"<ul> <li>unlock (jac::TimeoutLock)</li> <li>Uploader (jac::Uploader)</li> </ul>"},{"location":"doxygen/class_members/#w","title":"w","text":"<ul> <li>write (jac::LinkWritable)</li> </ul>"},{"location":"doxygen/class_members/#_1","title":"~","text":"<ul> <li>~Controller (jac::Controller)</li> <li>~Device (jac::Device)</li> <li>~KeyValueNamespace (jac::KeyValueNamespace)</li> <li>~LinkReadable (jac::LinkReadable)</li> <li>~Sha1Hasher (jac::Sha1Hasher)</li> <li>~Timeout (jac::Timeout)</li> <li>~TimeoutLock (jac::TimeoutLock)</li> <li>~Uploader (jac::Uploader)</li> </ul>"},{"location":"doxygen/class_members/#_","title":"_","text":"<ul> <li>_devLock (jac::Controller, jac::Uploader)</li> <li>_input (jac::Controller, jac::Uploader)</li> <li>_machineCtrl (jac::Controller)</li> <li>_output (jac::Controller, jac::Uploader)</li> <li>_stop (jac::Controller, jac::Timeout, jac::Uploader)</li> <li>_thread (jac::Controller, jac::LinkReadable, jac::Timeout, jac::Uploader)</li> <li>_versionInfo (jac::Controller, jac::Device)</li> <li>_controller (jac::Device)</li> <li>_getMemoryStats (jac::Device)</li> <li>_getStorageStats (jac::Device)</li> <li>_lastExitCode (jac::Device)</li> <li>_lock (jac::Device)</li> <li>_machine (jac::Device, jac::LinkReadable)</li> <li>_machineIO (jac::Device)</li> <li>_machineMutex (jac::Device)</li> <li>_machineRunning (jac::Device)</li> <li>_machineThread (jac::Device)</li> <li>_onConfigureMachine (jac::Device)</li> <li>_onKeyValueModified (jac::Device)</li> <li>_openKeyValueNamespace (jac::Device)</li> <li>_rootDir (jac::Device, jac::Uploader)</li> <li>_router (jac::Device)</li> <li>_uploader (jac::Device)</li> <li>_comm (jac::LinkReadable, jac::LinkWritable)</li> <li>_running (jac::LinkReadable, jac::Timeout)</li> <li>_debugStream (jac::Logger)</li> <li>_errorStream (jac::Logger)</li> <li>_logStream (jac::Logger)</li> <li>_ctx (jac::Sha1Hasher)</li> <li>_res (jac::Sha1Hasher)</li> <li>_callback (jac::Timeout, jac::TimeoutLock)</li> <li>_cv (jac::Timeout)</li> <li>_duration (jac::Timeout)</li> <li>_endTime (jac::Timeout)</li> <li>_mutex (jac::Timeout, jac::TimeoutLock)</li> <li>_locked (jac::TimeoutLock)</li> <li>_owner (jac::TimeoutLock)</li> <li>_stops (jac::TimeoutLock)</li> <li>_timeout (jac::TimeoutLock)</li> <li>_file (jac::Uploader)</li> <li>_formatFS (jac::Uploader)</li> <li>_onData (jac::Uploader)</li> <li>_onDataComplete (jac::Uploader)</li> <li>_resources (jac::Uploader)</li> <li>_state (jac::Uploader)</li> </ul>"},{"location":"doxygen/class_member_functions/","title":"Class Member Functions","text":""},{"location":"doxygen/class_member_functions/#a","title":"a","text":"<ul> <li>addProperties (jac::KeyValueNamespaceProtoBuilder)</li> </ul>"},{"location":"doxygen/class_member_functions/#c","title":"c","text":"<ul> <li>Controller (jac::Controller)</li> <li>configureMachine (jac::Device)</li> <li>commit (jac::KeyValueNamespace)</li> </ul>"},{"location":"doxygen/class_member_functions/#d","title":"d","text":"<ul> <li>Device (jac::Device)</li> <li>debug (jac::Logger)</li> </ul>"},{"location":"doxygen/class_member_functions/#e","title":"e","text":"<ul> <li>emitKeyValueModified (jac::Device, jac::MachineCtrl)</li> <li>erase (jac::KeyValueNamespace)</li> <li>exists (jac::KeyValueNamespace)</li> <li>error (jac::Logger)</li> </ul>"},{"location":"doxygen/class_member_functions/#f","title":"f","text":"<ul> <li>forceUnlock (jac::TimeoutLock)</li> </ul>"},{"location":"doxygen/class_member_functions/#g","title":"g","text":"<ul> <li>getKeyValueOpener (jac::Device)</li> <li>getMachineStatus (jac::Device, jac::MachineCtrl)</li> <li>getFloat (jac::KeyValueNamespace)</li> <li>getInt (jac::KeyValueNamespace)</li> <li>getString (jac::KeyValueNamespace)</li> <li>getType (jac::KeyValueNamespace)</li> <li>get (jac::KeyValueNamespaceProtoBuilder, jac::LinkReadable)</li> </ul>"},{"location":"doxygen/class_member_functions/#i","title":"i","text":"<ul> <li>initialize (jac::KeyValueFeature)</li> <li>init (jac::Timeout, jac::TimeoutLock)</li> </ul>"},{"location":"doxygen/class_member_functions/#k","title":"k","text":"<ul> <li>KeyValueFeature (jac::KeyValueFeature)</li> <li>KeyValueNamespace (jac::KeyValueNamespace)</li> <li>keys (jac::KeyValueNamespace)</li> </ul>"},{"location":"doxygen/class_member_functions/#l","title":"l","text":"<ul> <li>lock (jac::Device, jac::TimeoutLock)</li> <li>lockTimeout (jac::Device, jac::Uploader)</li> <li>LinkReadable (jac::LinkReadable)</li> <li>LinkWritable (jac::LinkWritable)</li> <li>log (jac::Logger)</li> </ul>"},{"location":"doxygen/class_member_functions/#m","title":"m","text":"<ul> <li>machineIO (jac::Device)</li> <li>MBEDTLS_PRIVATE (mbedtls_sha1_context)</li> </ul>"},{"location":"doxygen/class_member_functions/#o","title":"o","text":"<ul> <li>onConfigureMachine (jac::Device)</li> <li>onKeyValueModified (jac::Device)</li> <li>openKeyValue (jac::Device, jac::MachineCtrl)</li> <li>operator= (jac::Device, jac::Timeout, jac::TimeoutLock, jac::Uploader)</li> <li>ownedBy (jac::TimeoutLock)</li> </ul>"},{"location":"doxygen/class_member_functions/#p","title":"p","text":"<ul> <li>processConfigErase (jac::Controller)</li> <li>processConfigGet (jac::Controller)</li> <li>processConfigSet (jac::Controller)</li> <li>processForceUnlock (jac::Controller)</li> <li>processLock (jac::Controller)</li> <li>processPacket (jac::Controller, jac::Uploader)</li> <li>processStart (jac::Controller)</li> <li>processStatus (jac::Controller)</li> <li>processStop (jac::Controller)</li> <li>processUnlock (jac::Controller)</li> <li>processVersion (jac::Controller)</li> <li>processFile (jac::Sha1Hasher)</li> <li>processCreateDir (jac::Uploader)</li> <li>processDeleteDir (jac::Uploader)</li> <li>processDeleteFile (jac::Uploader)</li> <li>processFormatStorage (jac::Uploader)</li> <li>processGetHashes (jac::Uploader)</li> <li>processListDir (jac::Uploader)</li> <li>processListResources (jac::Uploader)</li> <li>processReadFile (jac::Uploader)</li> <li>processReadResource (jac::Uploader)</li> <li>processWriteFile (jac::Uploader)</li> </ul>"},{"location":"doxygen/class_member_functions/#r","title":"r","text":"<ul> <li>router (jac::Device)</li> <li>read (jac::LinkReadable)</li> <li>reset (jac::Timeout)</li> <li>resetTimeout (jac::TimeoutLock)</li> </ul>"},{"location":"doxygen/class_member_functions/#s","title":"s","text":"<ul> <li>start (jac::Controller, jac::Device, jac::Timeout, jac::Uploader)</li> <li>startMachine (jac::Device, jac::MachineCtrl)</li> <li>stopMachine (jac::Device, jac::MachineCtrl)</li> <li>setFloat (jac::KeyValueNamespace)</li> <li>setInt (jac::KeyValueNamespace)</li> <li>setString (jac::KeyValueNamespace)</li> <li>startRead (jac::LinkReadable)</li> <li>Sha1Hasher (jac::Sha1Hasher)</li> <li>stop (jac::Timeout)</li> <li>stopTimeout (jac::TimeoutLock)</li> </ul>"},{"location":"doxygen/class_member_functions/#t","title":"t","text":"<ul> <li>Timeout (jac::Timeout)</li> <li>TimeoutLock (jac::TimeoutLock)</li> </ul>"},{"location":"doxygen/class_member_functions/#u","title":"u","text":"<ul> <li>unlock (jac::TimeoutLock)</li> <li>Uploader (jac::Uploader)</li> </ul>"},{"location":"doxygen/class_member_functions/#w","title":"w","text":"<ul> <li>write (jac::LinkWritable)</li> </ul>"},{"location":"doxygen/class_member_functions/#_1","title":"~","text":"<ul> <li>~Controller (jac::Controller)</li> <li>~Device (jac::Device)</li> <li>~KeyValueNamespace (jac::KeyValueNamespace)</li> <li>~LinkReadable (jac::LinkReadable)</li> <li>~Sha1Hasher (jac::Sha1Hasher)</li> <li>~Timeout (jac::Timeout)</li> <li>~TimeoutLock (jac::TimeoutLock)</li> <li>~Uploader (jac::Uploader)</li> </ul>"},{"location":"doxygen/class_member_variables/","title":"Class Member Variables","text":""},{"location":"doxygen/class_member_variables/#e","title":"e","text":"<ul> <li>err (jac::Device::MachineIO)</li> </ul>"},{"location":"doxygen/class_member_variables/#i","title":"i","text":"<ul> <li>in (jac::Device::MachineIO)</li> </ul>"},{"location":"doxygen/class_member_variables/#k","title":"k","text":"<ul> <li>kvOpener (jac::KeyValueFeature)</li> </ul>"},{"location":"doxygen/class_member_variables/#o","title":"o","text":"<ul> <li>out (jac::Device::MachineIO)</li> </ul>"},{"location":"doxygen/class_member_variables/#_","title":"_","text":"<ul> <li>_devLock (jac::Controller, jac::Uploader)</li> <li>_input (jac::Controller, jac::Uploader)</li> <li>_machineCtrl (jac::Controller)</li> <li>_output (jac::Controller, jac::Uploader)</li> <li>_stop (jac::Controller, jac::Timeout, jac::Uploader)</li> <li>_thread (jac::Controller, jac::LinkReadable, jac::Timeout, jac::Uploader)</li> <li>_versionInfo (jac::Controller, jac::Device)</li> <li>_controller (jac::Device)</li> <li>_getMemoryStats (jac::Device)</li> <li>_getStorageStats (jac::Device)</li> <li>_lastExitCode (jac::Device)</li> <li>_lock (jac::Device)</li> <li>_machine (jac::Device, jac::LinkReadable)</li> <li>_machineIO (jac::Device)</li> <li>_machineMutex (jac::Device)</li> <li>_machineRunning (jac::Device)</li> <li>_machineThread (jac::Device)</li> <li>_onConfigureMachine (jac::Device)</li> <li>_onKeyValueModified (jac::Device)</li> <li>_openKeyValueNamespace (jac::Device)</li> <li>_rootDir (jac::Device, jac::Uploader)</li> <li>_router (jac::Device)</li> <li>_uploader (jac::Device)</li> <li>_comm (jac::LinkReadable, jac::LinkWritable)</li> <li>_running (jac::LinkReadable, jac::Timeout)</li> <li>_debugStream (jac::Logger)</li> <li>_errorStream (jac::Logger)</li> <li>_logStream (jac::Logger)</li> <li>_ctx (jac::Sha1Hasher)</li> <li>_res (jac::Sha1Hasher)</li> <li>_callback (jac::Timeout, jac::TimeoutLock)</li> <li>_cv (jac::Timeout)</li> <li>_duration (jac::Timeout)</li> <li>_endTime (jac::Timeout)</li> <li>_mutex (jac::Timeout, jac::TimeoutLock)</li> <li>_locked (jac::TimeoutLock)</li> <li>_owner (jac::TimeoutLock)</li> <li>_stops (jac::TimeoutLock)</li> <li>_timeout (jac::TimeoutLock)</li> <li>_file (jac::Uploader)</li> <li>_formatFS (jac::Uploader)</li> <li>_onData (jac::Uploader)</li> <li>_onDataComplete (jac::Uploader)</li> <li>_resources (jac::Uploader)</li> <li>_state (jac::Uploader)</li> </ul>"},{"location":"doxygen/class_member_typedefs/","title":"Class Member Typedefs","text":""},{"location":"doxygen/class_member_typedefs/#k","title":"k","text":"<ul> <li>KvClass (jac::KeyValueFeature)</li> </ul>"},{"location":"doxygen/class_member_enums/","title":"Class Member Enums","text":""},{"location":"doxygen/class_member_enums/#c","title":"c","text":"<ul> <li>Command (jac::Controller, jac::Uploader)</li> </ul>"},{"location":"doxygen/class_member_enums/#d","title":"d","text":"<ul> <li>DataType (jac::KeyValueNamespace)</li> </ul>"},{"location":"doxygen/class_member_enums/#e","title":"e","text":"<ul> <li>Error (jac::Uploader)</li> </ul>"},{"location":"doxygen/class_member_enums/#s","title":"s","text":"<ul> <li>State (jac::Uploader)</li> </ul>"},{"location":"doxygen/namespace_members/","title":"Namespace Members","text":""},{"location":"doxygen/namespace_members/#d","title":"d","text":"<ul> <li>deleteDir (jac)</li> </ul>"},{"location":"doxygen/namespace_members/#g","title":"g","text":"<ul> <li>getAbsolute (jac)</li> </ul>"},{"location":"doxygen/namespace_members/#k","title":"k","text":"<ul> <li>KeyValueOpener (jac)</li> </ul>"},{"location":"doxygen/namespace_members/#l","title":"l","text":"<ul> <li>listDir (jac)</li> </ul>"},{"location":"doxygen/namespace_member_functions/","title":"Namespace Member Functions","text":""},{"location":"doxygen/namespace_member_functions/#d","title":"d","text":"<ul> <li>deleteDir (jac)</li> </ul>"},{"location":"doxygen/namespace_member_functions/#g","title":"g","text":"<ul> <li>getAbsolute (jac)</li> </ul>"},{"location":"doxygen/namespace_member_functions/#l","title":"l","text":"<ul> <li>listDir (jac)</li> </ul>"},{"location":"doxygen/namespace_member_variables/","title":"Namespace Member Variables","text":"<p>Nothing related to Namespace Member Variables found.</p>"},{"location":"doxygen/namespace_member_typedefs/","title":"Namespace Member Typedefs","text":""},{"location":"doxygen/namespace_member_typedefs/#k","title":"k","text":"<ul> <li>KeyValueOpener (jac)</li> </ul>"},{"location":"doxygen/namespace_member_enums/","title":"Namespace Member Enums","text":"<p>Nothing related to Namespace Member Enums found.</p>"},{"location":"doxygen/functions/","title":"Functions","text":""},{"location":"doxygen/functions/#m","title":"m","text":"<ul> <li>mbedtls_internal_sha1_process (sha1.h)</li> <li>mbedtls_sha1 (sha1.h)</li> <li>mbedtls_sha1_clone (sha1.h)</li> <li>mbedtls_sha1_finish (sha1.h)</li> <li>mbedtls_sha1_free (sha1.h)</li> <li>mbedtls_sha1_init (sha1.h)</li> <li>mbedtls_sha1_starts (sha1.h)</li> <li>mbedtls_sha1_update (sha1.h)</li> </ul>"},{"location":"doxygen/macros/","title":"Macros","text":""},{"location":"doxygen/macros/#m","title":"m","text":"<ul> <li>MBEDTLS_ERR_ERROR_CORRUPTION_DETECTED (sha1.h)</li> <li>MBEDTLS_ERR_SHA1_BAD_INPUT_DATA (sha1.h)</li> <li>MBEDTLS_PRIVATE (sha1.h)</li> </ul>"},{"location":"doxygen/variables/","title":"Variables","text":""},{"location":"doxygen/variables/#m","title":"m","text":"<ul> <li>mbedtls_sha1_context (sha1.h)</li> </ul>"},{"location":"doxygen/links/","title":"Links","text":"<ul> <li>Related Pages</li> <li>Modules</li> <li>Class List</li> <li>Namespace ListNamespace List</li> <li>Namespace Members</li> <li>Namespace Member Functions</li> <li>Namespace Member Variables</li> <li>Namespace Member Typedefs</li> <li>Namespace Member Enumerations</li> <li>Class Index</li> <li>Class Hierarchy</li> <li>Class Members</li> <li>Class Member Functions</li> <li>Class Member Variables</li> <li>Class Member Typedefs</li> <li>Class Member Enumerations</li> <li>Files</li> <li>File Variables</li> <li>File Functions</li> <li>File Macros</li> </ul>"}]}